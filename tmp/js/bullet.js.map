{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/combokeys/Combokeys/index.js","bullet.js","node_modules/combokeys/Combokeys/prototype/addEvents.js","node_modules/combokeys/Combokeys/prototype/bind.js","node_modules/combokeys/Combokeys/prototype/bindMultiple.js","node_modules/combokeys/Combokeys/prototype/bindSequence.js","node_modules/combokeys/Combokeys/prototype/bindSingle.js","node_modules/combokeys/Combokeys/prototype/detach.js","node_modules/combokeys/Combokeys/prototype/dom-event.js","node_modules/combokeys/Combokeys/prototype/fireCallback.js","node_modules/combokeys/Combokeys/prototype/getKeyInfo.js","node_modules/combokeys/Combokeys/prototype/getMatches.js","node_modules/combokeys/Combokeys/prototype/getReverseMap.js","node_modules/combokeys/Combokeys/prototype/handleKey.js","node_modules/combokeys/Combokeys/prototype/handleKeyEvent.js","node_modules/combokeys/Combokeys/prototype/modifiersMatch.js","node_modules/combokeys/Combokeys/prototype/pickBestAction.js","node_modules/combokeys/Combokeys/prototype/reset.js","node_modules/combokeys/Combokeys/prototype/resetSequenceTimer.js","node_modules/combokeys/Combokeys/prototype/resetSequences.js","node_modules/combokeys/Combokeys/prototype/stopCallback.js","node_modules/combokeys/Combokeys/prototype/trigger.js","node_modules/combokeys/Combokeys/prototype/unbind.js","node_modules/combokeys/Combokeys/reset.js","node_modules/combokeys/helpers/characterFromEvent.js","node_modules/combokeys/helpers/eventModifiers.js","node_modules/combokeys/helpers/isModifier.js","node_modules/combokeys/helpers/keysFromString.js","node_modules/combokeys/helpers/preventDefault.js","node_modules/combokeys/helpers/shift-map.js","node_modules/combokeys/helpers/special-aliases.js","node_modules/combokeys/helpers/special-characters-map.js","node_modules/combokeys/helpers/special-keys-map.js","node_modules/combokeys/helpers/stopPropagation.js","src/js/bullet.js","src/js/draw.js","src/js/keyboard.js","src/js/pattern.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","element","self","this","Combokeys","constructor","callbacks","directMap","sequenceLevels","resetTimer","ignoreNextKeyup","ignoreNextKeypress","nextExpectedAction","addEvents","instances","push","prototype","bind","bindMultiple","unbind","trigger","reset","stopCallback","handleKey","bindSingle","getKeyInfo","pickBestAction","getReverseMap","getMatches","resetSequences","fireCallback","bindSequence","resetSequenceTimer","detach","REVERSE_MAP","./prototype/addEvents","./prototype/bind","./prototype/bindMultiple","./prototype/bindSequence","./prototype/bindSingle","./prototype/detach","./prototype/fireCallback","./prototype/getKeyInfo","./prototype/getMatches","./prototype/getReverseMap","./prototype/handleKey","./prototype/pickBestAction","./prototype/reset.js","./prototype/resetSequenceTimer","./prototype/resetSequences","./prototype/stopCallback","./prototype/trigger","./prototype/unbind","./reset","2","on","eventHandler","./dom-event","./handleKeyEvent","3","keys","callback","action","Array","4","combinations","j","5","combo","increaseSequence","nextAction","callbackAndReset","characterFromEvent","setTimeout","isFinal","wrappedCallback","../../helpers/characterFromEvent","6","combination","sequenceName","level","replace","info","sequence","split","key","modifiers","type","seq","7","off","8","event","capture","addEventListener","attachEvent","removeEventListener","detachEvent","9","preventDefault","stopPropagation","target","srcElement","../../helpers/preventDefault","../../helpers/stopPropagation","10","keysFromString","SPECIAL_ALIASES","SHIFT_MAP","isModifier","../../helpers/isModifier","../../helpers/keysFromString","../../helpers/shift-map","../../helpers/special-aliases","11","character","modifiersMatch","matches","slice","anyCharCallbacks","forEach","metaKey","ctrlKey","deleteCombo","deleteSequence","splice","./modifiersMatch","12","SPECIAL_KEYS_MAP","hasOwnProperty","../../helpers/special-keys-map","13","ignoreThisKeypress","doNotReset","maxLevel","processedSequenceCallback","Math","max","14","eventModifiers","which","keyCode","../../helpers/eventModifiers","15","modifiers1","modifiers2","sort","join","16","17","18","clearTimeout","19","activeSequences","20","className","indexOf","tagName","toLowerCase","isContentEditable","21","22","23","combokeys","24","SPECIAL_CHARACTERS_MAP","String","fromCharCode","shiftKey","./special-characters-map","./special-keys-map","25","altKey","26","27","28","returnValue","29","~","!","@","#","$","%","^","&","*","(",")","_","+",":","\"","<",">","?","|","30","option","command","return","escape","mod","test","navigator","platform","31","106","107","109","110","111","186","187","188","189","190","191","192","219","220","221","222","32","33","34","35","36","37","38","39","40","45","46","91","93","224","cancelBubble","vec2","x","y","randColor","floor","random","toString","randInt","min","round","addBullet","bulletObject","bullets","array","randomBoundBullet","gameCanvas","width","height","draw","kb","pattern","menuCanvas","document","getElementById","m","getContext","g","player","pos","radius","speed","deinc","color","func","applyPlayerSpeed","obj","up","down","right","left","pytha","pos1","pos2","sqrt","distanceCheck","obj1","obj2","unclog","angle","acos","cos","sin","squareCheck","update","collision","bullet","isConnected","b","len","otherBullet","frame","swapArround","loop","menu","requestAnimationFrame","cur","game","clear","circle","xspeed","yspeed","speedpos","wavyDown","./draw","./keyboard","./pattern","ctx","fillStyle","beginPath","arc","PI","fill","line","moveTo","lineTo","lineWidth","strokeStyle","stroke","canvas","fillRect","text","size","font","fillText","canvasInput","documentElement","sideWays","awayFromCenter"],"mappings":"CAAA,QAAAA,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAK,GAAA,GAAAC,OAAA,uBAAAN,EAAA,IAAA,MAAAK,GAAAE,KAAA,mBAAAF,EAAA,GAAAG,GAAAX,EAAAG,IAAAS,WAAAb,GAAAI,GAAA,GAAAU,KAAAF,EAAAC,QAAA,SAAAd,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,EAAAA,EAAAF,IAAAa,EAAAA,EAAAC,QAAAd,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAS,QAAA,IAAA,GAAAL,GAAA,kBAAAD,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAa,OAAAX,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAa,GAAA,SAAAT,EAAAU,EAAAJ,GCCA,YAEAI,GAAAJ,QAAA,SAAAK,GACA,GAAAC,GAAAC,KACAC,EAAAF,EAAAG,WA0DA,OAnDAH,GAAAI,aAOAJ,EAAAK,aAQAL,EAAAM,kBAOAN,EAAAO,WAOAP,EAAAQ,iBAAA,EAOAR,EAAAS,oBAAA,EAQAT,EAAAU,oBAAA,EAEAV,EAAAD,QAAAA,EAEAC,EAAAW,YAEAT,EAAAU,UAAAC,KAAAb,GACAA,GAGAF,EAAAJ,QAAAoB,UAAAC,KAAA3B,EAAA,oBACAU,EAAAJ,QAAAoB,UAAAE,aAAA5B,EAAA,4BACAU,EAAAJ,QAAAoB,UAAAG,OAAA7B,EAAA,sBACAU,EAAAJ,QAAAoB,UAAAI,QAAA9B,EAAA,uBACAU,EAAAJ,QAAAoB,UAAAK,MAAA/B,EAAA,wBACAU,EAAAJ,QAAAoB,UAAAM,aAAAhC,EAAA,4BACAU,EAAAJ,QAAAoB,UAAAO,UAAAjC,EAAA,yBACAU,EAAAJ,QAAAoB,UAAAH,UAAAvB,EAAA,yBACAU,EAAAJ,QAAAoB,UAAAQ,WAAAlC,EAAA,0BACAU,EAAAJ,QAAAoB,UAAAS,WAAAnC,EAAA,0BACAU,EAAAJ,QAAAoB,UAAAU,eAAApC,EAAA,8BACAU,EAAAJ,QAAAoB,UAAAW,cAAArC,EAAA,6BACAU,EAAAJ,QAAAoB,UAAAY,WAAAtC,EAAA,0BACAU,EAAAJ,QAAAoB,UAAAa,eAAAvC,EAAA,8BACAU,EAAAJ,QAAAoB,UAAAc,aAAAxC,EAAA,4BACAU,EAAAJ,QAAAoB,UAAAe,aAAAzC,EAAA,4BACAU,EAAAJ,QAAAoB,UAAAgB,mBAAA1C,EAAA,kCACAU,EAAAJ,QAAAoB,UAAAiB,OAAA3C,EAAA,sBAEAU,EAAAJ,QAAAkB,aACAd,EAAAJ,QAAAyB,MAAA/B,EAAA,WASAU,EAAAJ,QAAAsC,YAAA,OCGGC,wBAAwB,EAAEC,mBAAmB,EAAEC,2BAA2B,EAAEC,2BAA2B,EAAEC,yBAAyB,EAAEC,qBAAqB,EAAEC,2BAA2B,EAAEC,yBAAyB,GAAGC,yBAAyB,GAAGC,4BAA4B,GAAGC,wBAAwB,GAAGC,6BAA6B,GAAGC,uBAAuB,GAAGC,iCAAiC,GAAGC,6BAA6B,GAAGC,2BAA2B,GAAGC,sBAAsB,GAAGC,qBAAqB,GAAGC,UAAU,KAAKC,GAAG,SAAShE,EAAQU,EAAOJ,GCjGpiB,YACAI,GAAAJ,QAAA,WACA,GAAAM,GAAAC,KACAoD,EAAAjE,EAAA,eACAW,EAAAC,EAAAD,OAEAC,GAAAsD,aAAAlE,EAAA,oBAAA2B,KAAAf,GAEAqD,EAAAtD,EAAA,WAAAC,EAAAsD,cACAD,EAAAtD,EAAA,UAAAC,EAAAsD,cACAD,EAAAtD,EAAA,QAAAC,EAAAsD,iBDsGGC,cAAc,EAAEC,mBAAmB,KAAKC,GAAG,SAASrE,EAAQU,EAAOJ,GEhHtE,YAeAI,GAAAJ,QAAA,SAAAgE,EAAAC,EAAAC,GACA,GAAA5D,GAAAC,IAIA,OAFAyD,GAAAA,YAAAG,OAAAH,GAAAA,GACA1D,EAAAgB,aAAA0C,EAAAC,EAAAC,GACA5D,QFqHM8D,GAAG,SAAS1E,EAAQU,EAAOJ,GGzIjC,YAUAI,GAAAJ,QAAA,SAAAqE,EAAAJ,EAAAC,GAGA,IAAA,GAFA5D,GAAAC,KAEA+D,EAAA,EAAAA,EAAAD,EAAAnE,SAAAoE,EACAhE,EAAAsB,WAAAyC,EAAAC,GAAAL,EAAAC,SH+IMK,GAAG,SAAS7E,EAAQU,EAAOJ,GI7JjC,YAWAI,GAAAJ,QAAA,SAAAwE,EAAAR,EAAAC,EAAAC,GAcA,QAAAO,GAAAC,GACA,MAAA,YACApE,EAAAU,mBAAA0D,IACApE,EAAAM,eAAA4D,GACAlE,EAAA8B,sBAWA,QAAAuC,GAAAzF,GACA,GAAA0F,EACAtE,GAAA4B,aAAA+B,EAAA/E,EAAAsF,GAKA,UAAAN,IACAU,EAAAlF,EAAA,oCACAY,EAAAQ,gBAAA8D,EAAA1F,IAKA2F,WACA,WACAvE,EAAA2B,kBAEA,IA9CA,GAAA3B,GAAAC,IAIAD,GAAAM,eAAA4D,GAAA,CAuDA,KAAA,GAAAF,GAAA,EAAAA,EAAAN,EAAA9D,SAAAoE,EAAA,CACA,GAAAQ,GAAAR,EAAA,IAAAN,EAAA9D,OACA6E,EAAAD,EAAAH,EAAAF,EAAAP,GAAA5D,EAAAuB,WAAAmC,EAAAM,EAAA,IAAAJ,OACA5D,GAAAsB,WAAAoC,EAAAM,GAAAS,EAAAb,EAAAM,EAAAF,OJmKGU,mCAAmC,KAAKC,GAAG,SAASvF,EAAQU,EAAOJ,GK7OtE,YAYAI,GAAAJ,QAAA,SAAAkF,EAAAjB,EAAAC,EAAAiB,EAAAC,GACA,GAAA9E,GAAAC,IAGAD,GAAAK,UAAAuE,EAAA,IAAAhB,GAAAD,EAGAiB,EAAAA,EAAAG,QAAA,OAAA,IAEA,IACAC,GADAC,EAAAL,EAAAM,MAAA,IAKA,OAAAD,GAAArF,OAAA,MACAI,GAAA6B,aAAA+C,EAAAK,EAAAtB,EAAAC,IAIAoB,EAAAhF,EAAAuB,WAAAqD,EAAAhB,GAIA5D,EAAAI,UAAA4E,EAAAG,KAAAnF,EAAAI,UAAA4E,EAAAG,SAGAnF,EAAA0B,WAAAsD,EAAAG,IAAAH,EAAAI,WAAAC,KAAAL,EAAApB,QAAAiB,EAAAD,EAAAE,OAQA9E,GAAAI,UAAA4E,EAAAG,KAAAN,EAAA,UAAA,SACAlB,SAAAA,EACAyB,UAAAJ,EAAAI,UACAxB,OAAAoB,EAAApB,OACA0B,IAAAT,EACAC,MAAAA,EACAZ,MAAAU,WLmPMW,GAAG,SAASnG,EAAQU,EAAOJ,GMxSjC,GAAA8F,GAAApG,EAAA,eAAAoG,GACA1F,GAAAJ,QAAA,WACA,GAAAM,GAAAC,KACAF,EAAAC,EAAAD,OAEAyF,GAAAzF,EAAA,WAAAC,EAAAsD,cACAkC,EAAAzF,EAAA,UAAAC,EAAAsD,cACAkC,EAAAzF,EAAA,QAAAC,EAAAsD,iBN4SGC,cAAc,IAAIkC,GAAG,SAASrG,EAAQU,EAAOJ,GO/ShD,QAAA2D,GAAAtD,EAAA2F,EAAA/B,EAAAgC,GAGA,OAFA5F,EAAA6F,mBAAAF,EAAA,KAAAA,IACA3F,EAAA6F,kBAAA7F,EAAA8F,aAAAlG,KAAAI,EAAA2F,EAAA/B,EAAAgC,GACAhC,EAGA,QAAA6B,GAAAzF,EAAA2F,EAAA/B,EAAAgC,GAGA,OAFA5F,EAAA+F,sBAAAJ,EAAA,KAAAA,IACA3F,EAAA+F,qBAAA/F,EAAAgG,aAAApG,KAAAI,EAAA2F,EAAA/B,EAAAgC,GACAhC,EAbA7D,EAAAJ,QAAA2D,EACAvD,EAAAJ,QAAA2D,GAAAA,EACAvD,EAAAJ,QAAA8F,IAAAA,OPkUMQ,GAAG,SAAS5G,EAAQU,EAAOJ,GQnUjC,YAYAI,GAAAJ,QAAA,SAAAiE,EAAA/E,EAAAsF,EAAAe,GACA,GACAgB,GACAC,EAFAlG,EAAAC,IAKAD,GAAAoB,aAAAxC,EAAAA,EAAAuH,QAAAvH,EAAAwH,WAAAlC,EAAAe,IAIAtB,EAAA/E,EAAAsF,MAAA,IACA+B,EAAA7G,EAAA,gCACA6G,EAAArH,IACAsH,EAAA9G,EAAA,kCACAR,ORyUGyH,+BAA+B,GAAGC,gCAAgC,KAAKC,IAAI,SAASnH,EAAQU,EAAOJ,GSnWtG,YASAI,GAAAJ,QAAA,SAAAkF,EAAAhB,GACA,GACA4C,GACA9C,EACAyB,EACAnB,EAEAyC,EACAC,EACAC,EARA3G,EAAAC,KAKAmF,IAaA,KARAoB,EAAApH,EAAA,gCAGAsE,EAAA8C,EAAA5B,GAEA6B,EAAArH,EAAA,iCACAsH,EAAAtH,EAAA,2BACAuH,EAAAvH,EAAA,4BACA4E,EAAA,EAAAA,EAAAN,EAAA9D,SAAAoE,EACAmB,EAAAzB,EAAAM,GAGAyC,EAAAtB,KACAA,EAAAsB,EAAAtB,IAMAvB,GAAA,aAAAA,GAAA8C,EAAAvB,KACAA,EAAAuB,EAAAvB,GACAC,EAAAvE,KAAA,UAIA8F,EAAAxB,IACAC,EAAAvE,KAAAsE,EAQA,OAFAvB,GAAA5D,EAAAwB,eAAA2D,EAAAC,EAAAxB,IAGAuB,IAAAA,EACAC,UAAAA,EACAxB,OAAAA,MTyWGgD,2BAA2B,GAAGC,+BAA+B,GAAGC,0BAA0B,GAAGC,gCAAgC,KAAKC,IAAI,SAAS5H,EAAQU,EAAOJ,GUlajK,YAcAI,GAAAJ,QAAA,SAAAuH,EAAA7B,EAAAxG,EAAAiG,EAAAD,EAAAE,GACA,GACAd,GACAL,EAGAgD,EACAO,EANAlH,EAAAC,KAGAkH,KACAvD,EAAAhF,EAAAyG,IAIA,IACA,aAAAzB,KAEAhF,EAAAY,MAAA,UAAAZ,EAAAY,KAAA4H,MAAA,EAAA,IACA,CAEA,GAAAC,GAAArH,EAAAI,UAAA,oBACAiH,GAAAC,QAAA,SAAA3D,GACAwD,EAAAtG,KAAA8C,KAIA,IAAA3D,EAAAI,UAAA6G,GAAA,MAAAE,EAUA,KARAR,EAAAvH,EAAA,4BAEA,UAAAwE,GAAA+C,EAAAM,KACA7B,GAAA6B,IAKAjD,EAAA,EAAAA,EAAAhE,EAAAI,UAAA6G,GAAArH,SAAAoE,EAKA,GAJAL,EAAA3D,EAAAI,UAAA6G,GAAAjD,IAIAa,IAAAlB,EAAA2B,KAAAtF,EAAAM,eAAAqD,EAAA2B,OAAA3B,EAAAmB,QAMAlB,IAAAD,EAAAC,SAWAsD,EAAA9H,EAAA,oBACA,aAAAwE,IAAAhF,EAAA2I,UAAA3I,EAAA4I,SAAAN,EAAA9B,EAAAzB,EAAAyB,YAAA,CAMA,GAAAqC,IAAA5C,GAAAlB,EAAAO,QAAAU,EACA8C,EAAA7C,GAAAlB,EAAA2B,MAAAT,GAAAlB,EAAAmB,QAAAA,GACA2C,GAAAC,IACA1H,EAAAI,UAAA6G,GAAAU,OAAA3D,EAAA,GAGAmD,EAAAtG,KAAA8C,GAIA,MAAAwD,MVuaGP,2BAA2B,GAAGgB,mBAAmB,KAAKC,IAAI,SAASzI,EAAQU,EAAOJ,GW3frF,YAQAI,GAAAJ,QAAA,WACA,GAEAoI,GAFA9H,EAAAC,KACAE,EAAAH,EAAAG,WAGA,KAAAA,EAAA6B,YAAA,CACA7B,EAAA6B,eACA8F,EAAA1I,EAAA,iCACA,KAAA,GAAA+F,KAAA2C,GAGA3C,EAAA,IAAAA,EAAA,KAIA2C,EAAAC,eAAA5C,KACAhF,EAAA6B,YAAA8F,EAAA3C,IAAAA,GAIA,MAAAhF,GAAA6B,eXggBGgG,iCAAiC,KAAKC,IAAI,SAAS7I,EAAQU,EAAOJ,GY5hBrE,YAUAI,GAAAJ,QAAA,SAAAuH,EAAA7B,EAAAxG,GACA,GACAwB,GACA4D,EAIA2C,EACAuB,EAPAlI,EAAAC,KAGAkI,KACAC,EAAA,EACAC,GAAA,CAMA,KAFAjI,EAAAJ,EAAA0B,WAAAuF,EAAA7B,EAAAxG,GAEAoF,EAAA,EAAAA,EAAA5D,EAAAR,SAAAoE,EACA5D,EAAA4D,GAAAsB,MACA8C,EAAAE,KAAAC,IAAAH,EAAAhI,EAAA4D,GAAAc,OAKA,KAAAd,EAAA,EAAAA,EAAA5D,EAAAR,SAAAoE,EAMA,GAAA5D,EAAA4D,GAAAsB,IAAA,CASA,GAAAlF,EAAA4D,GAAAc,QAAAsD,EACA,QAGAC,IAAA,EAGAF,EAAA/H,EAAA4D,GAAAsB,KAAA,EACAtF,EAAA4B,aAAAxB,EAAA4D,GAAAL,SAAA/E,EAAAwB,EAAA4D,GAAAE,MAAA9D,EAAA4D,GAAAsB,SAMA+C,IACArI,EAAA4B,aAAAxB,EAAA4D,GAAAL,SAAA/E,EAAAwB,EAAA4D,GAAAE,MAyBAgE,GAAA,aAAAtJ,EAAAyG,MAAArF,EAAAS,mBACAkG,EAAAvH,EAAA,4BACAR,EAAAyG,OAAArF,EAAAU,oBAAAiG,EAAAM,IAAAiB,GACAlI,EAAA2B,eAAAwG,GAGAnI,EAAAS,mBAAA4H,GAAA,YAAAzJ,EAAAyG,QZiiBGuB,2BAA2B,KAAK4B,IAAI,SAASpJ,EAAQU,EAAOJ,Ga3nB/D,YAQAI,GAAAJ,QAAA,SAAAd,GACA,GACA0F,GACAmE,EAFAzI,EAAAC,IAMA,iBAAArB,GAAA8J,QACA9J,EAAA8J,MAAA9J,EAAA+J,SAEArE,EAAAlF,EAAA,mCACA,IAAA6H,GAAA3C,EAAA1F,EAGA,IAAAqI,EAAA,CAKA,GAAA,UAAArI,EAAAyG,MAAArF,EAAAQ,kBAAAyG,EAEA,YADAjH,EAAAQ,iBAAA,EAIAiI,GAAArJ,EAAA,gCACAY,EAAAqB,UAAA4F,EAAAwB,EAAA7J,GAAAA,ObgoBG8F,mCAAmC,GAAGkE,+BAA+B,KAAKC,IAAI,SAASzJ,EAAQU,EAAOJ,GcjqBzG,YASAI,GAAAJ,QAAA,SAAAoJ,EAAAC,GACA,MAAAD,GAAAE,OAAAC,KAAA,OAAAF,EAAAC,OAAAC,KAAA,WdsqBMC,IAAI,SAAS9J,EAAQU,EAAOJ,GehrBlC,YASAI,GAAAJ,QAAA,SAAAyF,EAAAC,EAAAxB,GACA,GAAA5D,GAAAC,IAcA,OAVA2D,KACAA,EAAA5D,EAAAyB,gBAAA0D,GAAA,UAAA,YAKA,aAAAvB,GAAAwB,EAAAxF,SACAgE,EAAA,WAGAA,QfqrBMuF,IAAI,SAAS/J,EAAQU,EAAOJ,GgB7sBlC,YASAI,GAAAJ,QAAA,WACA,GAAAM,GAAAC,IAGA,OAFAD,GAAAI,aACAJ,EAAAK,aACAJ,WhBktBMmJ,IAAI,SAAShK,EAAQU,EAAOJ,GiB/tBlC,YASAI,GAAAJ,QAAA,WACA,GAAAM,GAAAC,IAEAoJ,cAAArJ,EAAAO,YACAP,EAAAO,WAAAgE,WACA,WACAvE,EAAA2B,kBAEA,WjBquBM2H,IAAI,SAASlK,EAAQU,EAAOJ,GkBtvBlC,YAQAI,GAAAJ,QAAA,SAAAyI,GACA,GAAAnI,GAAAC,IAEAkI,GAAAA,KAEA,IACAhD,GADAoE,GAAA,CAGA,KAAApE,IAAAnF,GAAAM,eACA6H,EAAAhD,GACAoE,GAAA,EAGAvJ,EAAAM,eAAA6E,GAAA,CAGAoE,KACAvJ,EAAAU,oBAAA,SlB4vBM8I,IAAI,SAASpK,EAAQU,EAAOJ,GmBrxBlC,YASAI,GAAAJ,QAAA,SAAAd,EAAAmB,GAEA,IAAA,IAAAA,EAAA0J,UAAA,KAAAC,QAAA,kBACA,OAAA,CAGA,IAAAC,GAAA5J,EAAA4J,QAAAC,aAGA,OAAA,UAAAD,GAAA,WAAAA,GAAA,aAAAA,GAAA5J,EAAA8J,wBnB0xBMC,IAAI,SAAS1K,EAAQU,EAAOJ,GoB5yBlC,YAQAI,GAAAJ,QAAA,SAAAgE,EAAAE,GACA,GAAA5D,GAAAC,IAIA,OAHAD,GAAAK,UAAAqD,EAAA,IAAAE,IACA5D,EAAAK,UAAAqD,EAAA,IAAAE,MAAAF,GAEAzD,WpBizBM8J,IAAI,SAAS3K,EAAQU,EAAOJ,GqB9zBlC,YAkBAI,GAAAJ,QAAA,SAAAgE,EAAAE,GACA,GAAA5D,GAAAC,IAEA,OAAAD,GAAAe,KAAA2C,EAAA,aAAAE,SrBm0BMoG,IAAI,SAAS5K,EAAQU,EAAOJ,GsBx1BlC,YAEAI,GAAAJ,QAAA,WACA,GAAAM,GAAAC,IAEAD,GAAAY,UAAA0G,QAAA,SAAA2C,GACAA,EAAA9I,gBtB81BM+I,IAAI,SAAS9K,EAAQU,EAAOJ,GuBp2BlC,YAQAI,GAAAJ,QAAA,SAAAd,GACA,GAAAkJ,GACAqC,CAKA,IAJArC,EAAA1I,EAAA,sBACA+K,EAAA/K,EAAA,4BAGA,aAAAR,EAAAyG,KAAA,CACA,GAAA4B,GAAAmD,OAAAC,aAAAzL,EAAA8J,MAeA,OAJA9J,GAAA0L,WACArD,EAAAA,EAAA2C,eAGA3C,EAIA,MAAAa,GAAAlJ,EAAA8J,OACAZ,EAAAlJ,EAAA8J,OAGAyB,EAAAvL,EAAA8J,OACAyB,EAAAvL,EAAA8J,OAQA0B,OAAAC,aAAAzL,EAAA8J,OAAAkB,iBvBy2BGW,2BAA2B,GAAGC,qBAAqB,KAAKC,IAAI,SAASrL,EAAQU,EAAOJ,GwBz5BvF,YAQAI,GAAAJ,QAAA,SAAAd,GACA,GAAAwG,KAkBA,OAhBAxG,GAAA0L,UACAlF,EAAAvE,KAAA,SAGAjC,EAAA8L,QACAtF,EAAAvE,KAAA,OAGAjC,EAAA4I,SACApC,EAAAvE,KAAA,QAGAjC,EAAA2I,SACAnC,EAAAvE,KAAA,QAGAuE,QxB85BMuF,IAAI,SAASvL,EAAQU,EAAOJ,GyBz7BlC,YAQAI,GAAAJ,QAAA,SAAAyF,GACA,MAAA,UAAAA,GAAA,SAAAA,GAAA,QAAAA,GAAA,SAAAA,QzB87BMyF,IAAI,SAASxL,EAAQU,EAAOJ,G0Bv8BlC,YAQAI,GAAAJ,QAAA,SAAAkF,GACA,MAAA,MAAAA,GACA,KAGAA,EAAAM,MAAA,W1B48BM2F,IAAI,SAASzL,EAAQU,EAAOJ,G2Bz9BlC,YAQAI,GAAAJ,QAAA,SAAAd,GACA,MAAAA,GAAAqH,mBACArH,GAAAqH,sBAIArH,EAAAkM,aAAA,S3B89BMC,IAAI,SAAS3L,EAAQU,EAAOJ,G4B5+BlC,YAWAI,GAAAJ,SACAsL,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,EAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,EAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,W5Bi/BMC,IAAI,SAAS/M,EAAQU,EAAOJ,G6B/gClC,YAOAI,GAAAJ,SACA0M,OAAA,MACAC,QAAA,OACAC,SAAA,QACAC,OAAA,MACAC,IAAA,uBAAAC,KAAAC,UAAAC,UAAA,OAAA,a7BohCMC,IAAI,SAASxN,EAAQU,EAAOJ,G8BhiClC,YASAI,GAAAJ,SACAmN,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,KACAC,IAAA,IACAC,IAAA,U9BqiCMC,IAAI,SAASzO,EAAQU,EAAOJ,G+B9jClC,YAUAI,GAAAJ,SACA+F,EAAA,YACAO,EAAA,MACAiC,GAAA,QACAiB,GAAA,QACAC,GAAA,OACAC,GAAA,MACAI,GAAA,WACAoB,GAAA,MACAiD,GAAA,QACAC,GAAA,SACAC,GAAA,WACAC,GAAA,MACAC,GAAA,OACAC,GAAA,OACAC,GAAA,KACAC,GAAA,QACAC,GAAA,OACAC,GAAA,MACAC,GAAA,MACAC,GAAA,OACAC,GAAA,OACAtB,IAAA,OACAE,IAAA,QACAqB,IAAA,OAOA,KAAA,GAAArP,GAAA,EAAAA,EAAA,KAAAA,EACAS,EAAAJ,QAAA,IAAAL,GAAA,IAAAA,CAMA,KAAAA,EAAA,EAAAA,GAAA,IAAAA,EACAS,EAAAJ,QAAAL,EAAA,IAAAA,O/BmkCMyO,IAAI,SAAS1O,EAAQU,EAAOJ,GgCpnClC,YAQAI,GAAAJ,QAAA,SAAAd,GACA,MAAAA,GAAAsH,oBACAtH,GAAAsH,uBAIAtH,EAAA+P,cAAA,ShCynCMZ,IAAI,SAAS3O,EAAQU,EAAOJ,GiCznClC,QAAAkP,GAAAC,EAAAC,GACA,OAAAD,EAAAA,EAAAC,EAAAA,GAGA,QAAAC,KACA,MAAA,IAAAzG,KAAA0G,MAAA,SAAA1G,KAAA2G,UAAAC,SAAA,IAGA,QAAAC,GAAAC,EAAA7G,GACA,MAAAD,MAAA+G,MAAA/G,KAAA2G,SAAA1G,GAAA6G,EAcA,QAAAE,GAAAC,GACAC,EAAAC,MAAA5O,KAAA0O,GAGA,QAAAG,KACA,MAAApH,MAAA2G,UAAA,GACAL,EAAAO,EAAA,EAAAQ,EAAAC,OAAA,GAEAhB,EAAA,EAAAO,EAAA,EAAAQ,EAAAE,SA9CA,GAAAC,GAAA1Q,EAAA,UACA2Q,EAAA3Q,EAAA,cACA4Q,EAAA5Q,EAAA,aAEA6Q,EAAAC,SAAAC,eAAA,cACAC,EAAAH,EAAAI,WAAA,KACAJ,GAAAL,MAAA,IACAK,EAAAJ,OAAA,EACA,IAAAO,GAAAH,EAAAI,WAAA,MAEAV,EAAAO,SAAAC,eAAA,aACAR,GAAAC,MAAA,IACAD,EAAAE,OAAA,GACA,IAAAS,GAAAX,EAAAU,WAAA,MAcAE,GACAlL,KAAA,SACAmL,IAAA5B,EAAAe,EAAAC,MAAA,EAAAD,EAAAE,OAAA,GACAY,OAAA,EACAC,MAAA,EACAC,MAAA,GACAC,MAAA,QAGApB,GAAAC,UAcAoB,GACAC,iBAAA,SAAAC,GACAR,EAAAG,MAAA,IACAX,EAAAiB,KAAAD,EAAAP,IAAA1B,GAAAyB,EAAAG,OACAX,EAAAkB,OAAAF,EAAAP,IAAA1B,GAAAyB,EAAAG,OACAX,EAAAmB,QAAAH,EAAAP,IAAA3B,GAAA0B,EAAAG,OACAX,EAAAoB,OAAAJ,EAAAP,IAAA3B,GAAA0B,EAAAG,SAGAU,MAAA,SAAAC,EAAAC,GACA,MAAAhJ,MAAAiJ,MACAF,EAAAxC,EAAAyC,EAAAzC,IAAAwC,EAAAxC,EAAAyC,EAAAzC,IACAwC,EAAAvC,EAAAwC,EAAAxC,IAAAuC,EAAAvC,EAAAwC,EAAAxC,KAGA0C,cAAA,SAAAC,EAAAC,GAEA,MADAN,OAAAP,EAAAO,MAAAK,EAAAjB,IAAAkB,EAAAlB,KACAY,MAAAK,EAAAhB,OAAAiB,EAAAjB,QAGAkB,OAAA,SAAAF,EAAAC,GACA,GAAAE,GAAAtJ,KAAAuJ,MAAAJ,EAAAjB,IAAA3B,EAAA6C,EAAAlB,IAAA3B,GAAAgC,EAAAO,MAAAK,EAAAjB,IAAAkB,EAAAlB,KACAkB,GAAAlB,IAAA3B,EAAA4C,EAAAjB,IAAA3B,EAAAvG,KAAAwJ,IAAAF,IAAAH,EAAAhB,OAAAiB,EAAAjB,QAEAiB,EAAAlB,IAAA1B,EAAA2C,EAAAjB,IAAA1B,EACA4C,EAAAlB,IAAA1B,EAAA2C,EAAAjB,IAAA1B,EAAAxG,KAAAyJ,IAAAH,IAAAH,EAAAhB,OAAAiB,EAAAjB,QAEAiB,EAAAlB,IAAA1B,EAAA2C,EAAAjB,IAAA1B,EAAAxG,KAAAyJ,IAAAH,IAAAH,EAAAhB,OAAAiB,EAAAjB,SAIAuB,YAAA,SAAAP,EAAAC,GACA,QACAD,EAAAjB,IAAA3B,EAAA4C,EAAAhB,OAAAiB,EAAAlB,IAAA3B,EAAA6C,EAAAjB,QACAgB,EAAAjB,IAAA1B,EAAA2C,EAAAhB,OAAAiB,EAAAlB,IAAA1B,EAAA4C,EAAAjB,QACAgB,EAAAjB,IAAA3B,EAAA4C,EAAAhB,OAAAiB,EAAAlB,IAAA3B,EAAA6C,EAAAjB,QACAgB,EAAAjB,IAAA1B,EAAA2C,EAAAhB,OAAAiB,EAAAlB,IAAA1B,EAAA4C,EAAAjB,UAKAwB,GACAC,UAAA,SAAAC,GACA,GAAAA,EAAAC,YAEA,IAAA,GAAAC,GAAA,EAAAC,EAAA9C,EAAAC,MAAA7P,OAAAyS,EAAAC,EAAAD,IAAA,CACA,GAAAE,GAAA/C,EAAAC,MAAA4C,IACAE,EAAAH,aAAAvB,EAAAmB,YAAAG,EAAAI,IAAA1B,EAAAW,cAAAW,EAAAI,KAEA1B,EAAAc,OAAAQ,EAAAI,GACAA,EAAAH,aAAA,EACA7B,EAAAG,OAAA6B,EAAA9B,OAAA,SAKAI,GAAAmB,YAAAzB,EAAA4B,IAAAtB,EAAAW,cAAAjB,EAAA4B,IACAtB,EAAAc,OAAApB,EAAA4B,GAEAA,EAAAC,aAAA,EACA7B,EAAAG,OAAAyB,EAAA1B,OAAA,MAEA0B,EAAAnC,QAAAmC,EAAAK,GACAP,EAAAQ,YAAAN,KAKAM,YAAA,SAAA1B,GACAA,EAAAP,IAAA1B,EAAAa,EAAAE,aAAAkB,EAAAP,IAAA1B,GAAA,IAAAa,EAAAE,QACAkB,EAAAP,IAAA1B,EAAA,IAAAa,EAAAE,SAAAkB,EAAAP,IAAA1B,GAAA,IAAAa,EAAAE,QAEAkB,EAAAP,IAAA3B,EAAA,IAAAc,EAAAC,QAAAmB,EAAAP,IAAA3B,GAAA,IAAAc,EAAAE,QACAkB,EAAAP,IAAA3B,EAAAc,EAAAC,YAAAmB,EAAAP,IAAA3B,GAAA,IAAAc,EAAAE,UAIA2C,KACAE,GACAC,KAAA,WACAH,IAEAI,sBAAAF,EAAAG,MAEAC,KAAA,WACAN,IAEA1C,EAAAiD,MAAAzC,EAAAX,GAEAkB,EAAAC,iBAAAP,GACA0B,EAAAQ,YAAAlC,GACAT,EAAAkD,OAAA1C,EAAAC,EAAAC,IAAAD,EAAAE,OAAAF,EAAAK,MAEA,KAAA,GAAAvR,GAAA,EAAAiT,EAAA9C,EAAAC,MAAA7P,OAAAP,EAAAiT,EAAAjT,IAAA,CACA,GAAA8S,GAAA3C,EAAAC,MAAApQ,EACA8S,GAAAc,QAAA,KACAd,EAAAe,QAAA,KAEAf,EAAAC,aACAvB,EAAAC,iBAAAqB,GAGAF,EAAAC,UAAAC,EAAA9S,GACAyQ,EAAAkD,OAAA1C,EAAA6B,EAAA3B,IAAA2B,EAAA1B,OAAA0B,EAAAvB,OAGA4B,EAAA,KAAA,GACAlD,GACAkB,IAAAd,IACAe,OAAA,EAAAtB,EAAA,EAAA,GACAyB,MAAA7B,IACAoE,SAAAvE,EAAA,EAAA,EAAAtG,KAAA2G,SAAA,EAAA,EAAA3G,KAAA2G,UACAe,QAAAA,EAAAoD,WAIAtD,EAAAiD,MAAA3C,EAAAH,GAEA2C,sBAAAF,EAAAG,MAGAH,GAAAG,IAAAH,EAAAI,KACAJ,EAAAG,QjC2oCGQ,SAAS,GAAGC,aAAa,GAAGC,YAAY,KAAKvF,IAAI,SAAS5O,EAAQU,EAAOJ,GkCvzC5EI,EAAAJ,SACAsT,OAAA,SAAAQ,EAAAhD,EAAAC,EAAAG,GACA4C,EAAAC,UAAA7C,EACA4C,EAAAE,YACAF,EAAAG,IAAAnD,EAAA3B,EAAA2B,EAAA1B,EAAA2B,EAAA,EAAA,EAAAnI,KAAAsL,IACAJ,EAAAK,QAEAC,KAAA,SAAAN,EAAAnC,EAAAC,EAAA1B,EAAAgB,GACA4C,EAAAE,YACAF,EAAAO,OAAA1C,EAAAxC,EAAAwC,EAAAvC,GACA0E,EAAAQ,OAAA1C,EAAAzC,EAAAyC,EAAAxC,GACA0E,EAAAS,UAAArE,EACA4D,EAAAU,YAAAtD,EACA4C,EAAAW,UAEApB,MAAA,SAAAS,EAAAY,GACAZ,EAAAC,UAAA,QACAD,EAAAa,SAAA,EAAA,EAAAD,EAAAxE,MAAAwE,EAAAvE,SAGAyE,KAAA,SAAAd,EAAAc,EAAAC,EAAA3D,EAAAJ,GACAgD,EAAAC,UAAA7C,EACA4C,EAAAgB,KAAAD,EAAArF,WAAA,eACAsE,EAAAiB,SAAAH,EAAA9D,EAAA3B,EAAA2B,EAAA1B,IAEA6D,KAAA,mBlC6zCM1E,IAAI,SAAS7O,EAAQU,EAAOJ,GmCt1ClC,GAAAQ,GAAAd,EAAA,aACAsV,EAAA,GAAAxU,GAAAgQ,SAAAyE,iBAEA5E,GACAiB,IAAA,EAAAC,MAAA,EAAAE,MAAA,EAAAD,OAAA,EAGAwD,GAAA3T,KAAA,KAAA,WAAAgP,EAAAiB,IAAA,GAAA,WACA0D,EAAA3T,KAAA,KAAA,WAAAgP,EAAAiB,IAAA,GAAA,SACA0D,EAAA3T,KAAA,OAAA,WAAAgP,EAAAkB,MAAA,GAAA,WACAyD,EAAA3T,KAAA,OAAA,WAAAgP,EAAAkB,MAAA,GAAA,SACAyD,EAAA3T,KAAA,OAAA,WAAAgP,EAAAoB,MAAA,GAAA,WACAuD,EAAA3T,KAAA,OAAA,WAAAgP,EAAAoB,MAAA,GAAA,SACAuD,EAAA3T,KAAA,QAAA,WAAAgP,EAAAmB,OAAA,GAAA,WACAwD,EAAA3T,KAAA,QAAA,WAAAgP,EAAAmB,OAAA,GAAA,SAEApR,EAAAJ,QAAAqQ,InCy1CG9F,UAAY,IAAIiE,IAAI,SAAS9O,EAAQU,EAAOJ,GoCz2C/CI,EAAAJ,SACAuR,KAAA,SAAAkB,GACAA,EAAA3B,IAAA1B,GAAAqD,EAAAgB,SAAArE,GAEA8F,SAAA,SAAAzC,GACAA,EAAA3B,IAAA1B,GAAAqD,EAAAgB,SAAArE,EACAqD,EAAA3B,IAAA3B,GAAAsD,EAAAgB,SAAAtE,GAEAuE,SAAA,SAAAjB,EAAAK,GACAL,EAAA3B,IAAA1B,GAAAqD,EAAAgB,SAAArE,EAAAxG,KAAAyJ,IAAA,EAAA,IACAI,EAAA3B,IAAA3B,GAAA,EAAAvG,KAAAyJ,IAAAS,GAAA,GAAAL,EAAAgB,SAAAtE,KAEAgG,eAAA,SAAA1C,EAAAhN,gBpC+2CW","file":"bullet.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* eslint-env node, browser */\n'use strict'\n\nmodule.exports = function (element) {\n  var self = this\n  var Combokeys = self.constructor\n\n  /**\n   * a list of all the callbacks setup via Combokeys.bind()\n   *\n   * @type {Object}\n   */\n  self.callbacks = {}\n\n  /**\n   * direct map of string combinations to callbacks used for trigger()\n   *\n   * @type {Object}\n   */\n  self.directMap = {}\n\n  /**\n   * keeps track of what level each sequence is at since multiple\n   * sequences can start out with the same sequence\n   *\n   * @type {Object}\n   */\n  self.sequenceLevels = {}\n\n  /**\n   * variable to store the setTimeout call\n   *\n   * @type {null|number}\n   */\n  self.resetTimer\n\n  /**\n   * temporary state where we will ignore the next keyup\n   *\n   * @type {boolean|string}\n   */\n  self.ignoreNextKeyup = false\n\n  /**\n   * temporary state where we will ignore the next keypress\n   *\n   * @type {boolean}\n   */\n  self.ignoreNextKeypress = false\n\n  /**\n   * are we currently inside of a sequence?\n   * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n   *\n   * @type {boolean|string}\n   */\n  self.nextExpectedAction = false\n\n  self.element = element\n\n  self.addEvents()\n\n  Combokeys.instances.push(self)\n  return self\n}\n\nmodule.exports.prototype.bind = require('./prototype/bind')\nmodule.exports.prototype.bindMultiple = require('./prototype/bindMultiple')\nmodule.exports.prototype.unbind = require('./prototype/unbind')\nmodule.exports.prototype.trigger = require('./prototype/trigger')\nmodule.exports.prototype.reset = require('./prototype/reset.js')\nmodule.exports.prototype.stopCallback = require('./prototype/stopCallback')\nmodule.exports.prototype.handleKey = require('./prototype/handleKey')\nmodule.exports.prototype.addEvents = require('./prototype/addEvents')\nmodule.exports.prototype.bindSingle = require('./prototype/bindSingle')\nmodule.exports.prototype.getKeyInfo = require('./prototype/getKeyInfo')\nmodule.exports.prototype.pickBestAction = require('./prototype/pickBestAction')\nmodule.exports.prototype.getReverseMap = require('./prototype/getReverseMap')\nmodule.exports.prototype.getMatches = require('./prototype/getMatches')\nmodule.exports.prototype.resetSequences = require('./prototype/resetSequences')\nmodule.exports.prototype.fireCallback = require('./prototype/fireCallback')\nmodule.exports.prototype.bindSequence = require('./prototype/bindSequence')\nmodule.exports.prototype.resetSequenceTimer = require('./prototype/resetSequenceTimer')\nmodule.exports.prototype.detach = require('./prototype/detach')\n\nmodule.exports.instances = []\nmodule.exports.reset = require('./reset')\n\n/**\n * variable to store the flipped version of MAP from above\n * needed to check if we should use keypress or not when no action\n * is specified\n *\n * @type {Object|undefined}\n */\nmodule.exports.REVERSE_MAP = null\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\nmodule.exports = function (element) {\n  var self = this\n  var Combokeys = self.constructor\n\n  /**\n   * a list of all the callbacks setup via Combokeys.bind()\n   *\n   * @type {Object}\n   */\n  self.callbacks = {}\n\n  /**\n   * direct map of string combinations to callbacks used for trigger()\n   *\n   * @type {Object}\n   */\n  self.directMap = {}\n\n  /**\n   * keeps track of what level each sequence is at since multiple\n   * sequences can start out with the same sequence\n   *\n   * @type {Object}\n   */\n  self.sequenceLevels = {}\n\n  /**\n   * variable to store the setTimeout call\n   *\n   * @type {null|number}\n   */\n  self.resetTimer\n\n  /**\n   * temporary state where we will ignore the next keyup\n   *\n   * @type {boolean|string}\n   */\n  self.ignoreNextKeyup = false\n\n  /**\n   * temporary state where we will ignore the next keypress\n   *\n   * @type {boolean}\n   */\n  self.ignoreNextKeypress = false\n\n  /**\n   * are we currently inside of a sequence?\n   * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n   *\n   * @type {boolean|string}\n   */\n  self.nextExpectedAction = false\n\n  self.element = element\n\n  self.addEvents()\n\n  Combokeys.instances.push(self)\n  return self\n}\n\nmodule.exports.prototype.bind = require('./prototype/bind')\nmodule.exports.prototype.bindMultiple = require('./prototype/bindMultiple')\nmodule.exports.prototype.unbind = require('./prototype/unbind')\nmodule.exports.prototype.trigger = require('./prototype/trigger')\nmodule.exports.prototype.reset = require('./prototype/reset.js')\nmodule.exports.prototype.stopCallback = require('./prototype/stopCallback')\nmodule.exports.prototype.handleKey = require('./prototype/handleKey')\nmodule.exports.prototype.addEvents = require('./prototype/addEvents')\nmodule.exports.prototype.bindSingle = require('./prototype/bindSingle')\nmodule.exports.prototype.getKeyInfo = require('./prototype/getKeyInfo')\nmodule.exports.prototype.pickBestAction = require('./prototype/pickBestAction')\nmodule.exports.prototype.getReverseMap = require('./prototype/getReverseMap')\nmodule.exports.prototype.getMatches = require('./prototype/getMatches')\nmodule.exports.prototype.resetSequences = require('./prototype/resetSequences')\nmodule.exports.prototype.fireCallback = require('./prototype/fireCallback')\nmodule.exports.prototype.bindSequence = require('./prototype/bindSequence')\nmodule.exports.prototype.resetSequenceTimer = require('./prototype/resetSequenceTimer')\nmodule.exports.prototype.detach = require('./prototype/detach')\n\nmodule.exports.instances = []\nmodule.exports.reset = require('./reset')\n\n/**\n * variable to store the flipped version of MAP from above\n * needed to check if we should use keypress or not when no action\n * is specified\n *\n * @type {Object|undefined}\n */\nmodule.exports.REVERSE_MAP = null\n\n},{\"./prototype/addEvents\":2,\"./prototype/bind\":3,\"./prototype/bindMultiple\":4,\"./prototype/bindSequence\":5,\"./prototype/bindSingle\":6,\"./prototype/detach\":7,\"./prototype/fireCallback\":9,\"./prototype/getKeyInfo\":10,\"./prototype/getMatches\":11,\"./prototype/getReverseMap\":12,\"./prototype/handleKey\":13,\"./prototype/pickBestAction\":16,\"./prototype/reset.js\":17,\"./prototype/resetSequenceTimer\":18,\"./prototype/resetSequences\":19,\"./prototype/stopCallback\":20,\"./prototype/trigger\":21,\"./prototype/unbind\":22,\"./reset\":23}],2:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\nmodule.exports = function () {\n  var self = this\n  var on = require('./dom-event')\n  var element = self.element\n\n  self.eventHandler = require('./handleKeyEvent').bind(self)\n\n  on(element, 'keypress', self.eventHandler)\n  on(element, 'keydown', self.eventHandler)\n  on(element, 'keyup', self.eventHandler)\n}\n\n},{\"./dom-event\":8,\"./handleKeyEvent\":14}],3:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n/**\n * binds an event to Combokeys\n *\n * can be a single key, a combination of keys separated with +,\n * an array of keys, or a sequence of keys separated by spaces\n *\n * be sure to list the modifier keys first to make sure that the\n * correct key ends up getting bound (the last key in the pattern)\n *\n * @param {string|Array} keys\n * @param {Function} callback\n * @param {string=} action - \"keypress\", \"keydown\", or \"keyup\"\n * @returns void\n */\nmodule.exports = function (keys, callback, action) {\n  var self = this\n\n  keys = keys instanceof Array ? keys : [keys]\n  self.bindMultiple(keys, callback, action)\n  return self\n}\n\n},{}],4:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * binds multiple combinations to the same callback\n *\n * @param {Array} combinations\n * @param {Function} callback\n * @param {string|undefined} action\n * @returns void\n */\nmodule.exports = function (combinations, callback, action) {\n  var self = this\n\n  for (var j = 0; j < combinations.length; ++j) {\n    self.bindSingle(combinations[j], callback, action)\n  }\n}\n\n},{}],5:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * binds a key sequence to an event\n *\n * @param {string} combo - combo specified in bind call\n * @param {Array} keys\n * @param {Function} callback\n * @param {string=} action\n * @returns void\n */\nmodule.exports = function (combo, keys, callback, action) {\n  var self = this\n\n  // start off by adding a sequence level record for this combination\n  // and setting the level to 0\n  self.sequenceLevels[combo] = 0\n\n  /**\n   * callback to increase the sequence level for this sequence and reset\n   * all other sequences that were active\n   *\n   * @param {string} nextAction\n   * @returns {Function}\n   */\n  function increaseSequence (nextAction) {\n    return function () {\n      self.nextExpectedAction = nextAction\n      ++self.sequenceLevels[combo]\n      self.resetSequenceTimer()\n    }\n  }\n\n  /**\n   * wraps the specified callback inside of another function in order\n   * to reset all sequence counters as soon as this sequence is done\n   *\n   * @param {Event} e\n   * @returns void\n   */\n  function callbackAndReset (e) {\n    var characterFromEvent\n    self.fireCallback(callback, e, combo)\n\n    // we should ignore the next key up if the action is key down\n    // or keypress.  this is so if you finish a sequence and\n    // release the key the final key will not trigger a keyup\n    if (action !== 'keyup') {\n      characterFromEvent = require('../../helpers/characterFromEvent')\n      self.ignoreNextKeyup = characterFromEvent(e)\n    }\n\n    // weird race condition if a sequence ends with the key\n    // another sequence begins with\n    setTimeout(\n      function () {\n        self.resetSequences()\n      },\n      10\n    )\n  }\n\n  // loop through keys one at a time and bind the appropriate callback\n  // function.  for any key leading up to the final one it should\n  // increase the sequence. after the final, it should reset all sequences\n  //\n  // if an action is specified in the original bind call then that will\n  // be used throughout.  otherwise we will pass the action that the\n  // next key in the sequence should match.  this allows a sequence\n  // to mix and match keypress and keydown events depending on which\n  // ones are better suited to the key provided\n  for (var j = 0; j < keys.length; ++j) {\n    var isFinal = j + 1 === keys.length\n    var wrappedCallback = isFinal ? callbackAndReset : increaseSequence(action || self.getKeyInfo(keys[j + 1]).action)\n    self.bindSingle(keys[j], wrappedCallback, action, combo, j)\n  }\n}\n\n},{\"../../helpers/characterFromEvent\":24}],6:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * binds a single keyboard combination\n *\n * @param {string} combination\n * @param {Function} callback\n * @param {string=} action\n * @param {string=} sequenceName - name of sequence if part of sequence\n * @param {number=} level - what part of the sequence the command is\n * @returns void\n */\nmodule.exports = function (combination, callback, action, sequenceName, level) {\n  var self = this\n\n  // store a direct mapped reference for use with Combokeys.trigger\n  self.directMap[combination + ':' + action] = callback\n\n  // make sure multiple spaces in a row become a single space\n  combination = combination.replace(/\\s+/g, ' ')\n\n  var sequence = combination.split(' ')\n  var info\n\n  // if this pattern is a sequence of keys then run through this method\n  // to reprocess each pattern one key at a time\n  if (sequence.length > 1) {\n    self.bindSequence(combination, sequence, callback, action)\n    return\n  }\n\n  info = self.getKeyInfo(combination, action)\n\n  // make sure to initialize array if this is the first time\n  // a callback is added for this key\n  self.callbacks[info.key] = self.callbacks[info.key] || []\n\n  // remove an existing match if there is one\n  self.getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level)\n\n  // add this call back to the array\n  // if it is a sequence put it at the beginning\n  // if not put it at the end\n  //\n  // this is important because the way these are processed expects\n  // the sequence ones to come first\n  self.callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n    callback: callback,\n    modifiers: info.modifiers,\n    action: info.action,\n    seq: sequenceName,\n    level: level,\n    combo: combination\n  })\n}\n\n},{}],7:[function(require,module,exports){\nvar off = require('./dom-event').off\nmodule.exports = function () {\n  var self = this\n  var element = self.element\n\n  off(element, 'keypress', self.eventHandler)\n  off(element, 'keydown', self.eventHandler)\n  off(element, 'keyup', self.eventHandler)\n}\n\n},{\"./dom-event\":8}],8:[function(require,module,exports){\nmodule.exports = on\nmodule.exports.on = on\nmodule.exports.off = off\n\nfunction on (element, event, callback, capture) {\n  !element.addEventListener && (event = 'on' + event)\n  ;(element.addEventListener || element.attachEvent).call(element, event, callback, capture)\n  return callback\n}\n\nfunction off (element, event, callback, capture) {\n  !element.removeEventListener && (event = 'on' + event)\n  ;(element.removeEventListener || element.detachEvent).call(element, event, callback, capture)\n  return callback\n}\n\n},{}],9:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * actually calls the callback function\n *\n * if your callback function returns false this will use the jquery\n * convention - prevent default and stop propogation on the event\n *\n * @param {Function} callback\n * @param {Event} e\n * @returns void\n */\nmodule.exports = function (callback, e, combo, sequence) {\n  var self = this\n  var preventDefault\n  var stopPropagation\n\n  // if this event should not happen stop here\n  if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n    return\n  }\n\n  if (callback(e, combo) === false) {\n    preventDefault = require('../../helpers/preventDefault')\n    preventDefault(e)\n    stopPropagation = require('../../helpers/stopPropagation')\n    stopPropagation(e)\n  }\n}\n\n},{\"../../helpers/preventDefault\":28,\"../../helpers/stopPropagation\":33}],10:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * Gets info for a specific key combination\n *\n * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n * @param  {string=} action\n * @returns {Object}\n */\nmodule.exports = function (combination, action) {\n  var self = this\n  var keysFromString\n  var keys\n  var key\n  var j\n  var modifiers = []\n  var SPECIAL_ALIASES\n  var SHIFT_MAP\n  var isModifier\n\n  keysFromString = require('../../helpers/keysFromString')\n  // take the keys from this pattern and figure out what the actual\n  // pattern is all about\n  keys = keysFromString(combination)\n\n  SPECIAL_ALIASES = require('../../helpers/special-aliases')\n  SHIFT_MAP = require('../../helpers/shift-map')\n  isModifier = require('../../helpers/isModifier')\n  for (j = 0; j < keys.length; ++j) {\n    key = keys[j]\n\n    // normalize key names\n    if (SPECIAL_ALIASES[key]) {\n      key = SPECIAL_ALIASES[key]\n    }\n\n    // if this is not a keypress event then we should\n    // be smart about using shift keys\n    // this will only work for US keyboards however\n    if (action && action !== 'keypress' && SHIFT_MAP[key]) {\n      key = SHIFT_MAP[key]\n      modifiers.push('shift')\n    }\n\n    // if this key is a modifier then add it to the list of modifiers\n    if (isModifier(key)) {\n      modifiers.push(key)\n    }\n  }\n\n  // depending on what the key combination is\n  // we will try to pick the best event for it\n  action = self.pickBestAction(key, modifiers, action)\n\n  return {\n    key: key,\n    modifiers: modifiers,\n    action: action\n  }\n}\n\n},{\"../../helpers/isModifier\":26,\"../../helpers/keysFromString\":27,\"../../helpers/shift-map\":29,\"../../helpers/special-aliases\":30}],11:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * finds all callbacks that match based on the keycode, modifiers,\n * and action\n *\n * @param {string} character\n * @param {Array} modifiers\n * @param {Event|Object} e\n * @param {string=} sequenceName - name of the sequence we are looking for\n * @param {string=} combination\n * @param {number=} level\n * @returns {Array}\n */\nmodule.exports = function (character, modifiers, e, sequenceName, combination, level) {\n  var self = this\n  var j\n  var callback\n  var matches = []\n  var action = e.type\n  var isModifier\n  var modifiersMatch\n\n  if (\n      action === 'keypress' &&\n      // Firefox fires keypress for arrows\n      !(e.code && e.code.slice(0, 5) === 'Arrow')\n  ) {\n    // 'any-character' callbacks are only on `keypress`\n    var anyCharCallbacks = self.callbacks['any-character'] || []\n    anyCharCallbacks.forEach(function (callback) {\n      matches.push(callback)\n    })\n  }\n\n  if (!self.callbacks[character]) { return matches }\n\n  isModifier = require('../../helpers/isModifier')\n  // if a modifier key is coming up on its own we should allow it\n  if (action === 'keyup' && isModifier(character)) {\n    modifiers = [character]\n  }\n\n  // loop through all callbacks for the key that was pressed\n  // and see if any of them match\n  for (j = 0; j < self.callbacks[character].length; ++j) {\n    callback = self.callbacks[character][j]\n\n    // if a sequence name is not specified, but this is a sequence at\n    // the wrong level then move onto the next match\n    if (!sequenceName && callback.seq && self.sequenceLevels[callback.seq] !== callback.level) {\n      continue\n    }\n\n    // if the action we are looking for doesn't match the action we got\n    // then we should keep going\n    if (action !== callback.action) {\n      continue\n    }\n\n    // if this is a keypress event and the meta key and control key\n    // are not pressed that means that we need to only look at the\n    // character, otherwise check the modifiers as well\n    //\n    // chrome will not fire a keypress if meta or control is down\n    // safari will fire a keypress if meta or meta+shift is down\n    // firefox will fire a keypress if meta or control is down\n    modifiersMatch = require('./modifiersMatch')\n    if ((action === 'keypress' && !e.metaKey && !e.ctrlKey) || modifiersMatch(modifiers, callback.modifiers)) {\n      // when you bind a combination or sequence a second time it\n      // should overwrite the first one.  if a sequenceName or\n      // combination is specified in this call it does just that\n      //\n      // @todo make deleting its own method?\n      var deleteCombo = !sequenceName && callback.combo === combination\n      var deleteSequence = sequenceName && callback.seq === sequenceName && callback.level === level\n      if (deleteCombo || deleteSequence) {\n        self.callbacks[character].splice(j, 1)\n      }\n\n      matches.push(callback)\n    }\n  }\n\n  return matches\n}\n\n},{\"../../helpers/isModifier\":26,\"./modifiersMatch\":15}],12:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * reverses the map lookup so that we can look for specific keys\n * to see what can and can't use keypress\n *\n * @return {Object}\n */\nmodule.exports = function () {\n  var self = this\n  var constructor = self.constructor\n  var SPECIAL_KEYS_MAP\n\n  if (!constructor.REVERSE_MAP) {\n    constructor.REVERSE_MAP = {}\n    SPECIAL_KEYS_MAP = require('../../helpers/special-keys-map')\n    for (var key in SPECIAL_KEYS_MAP) {\n      // pull out the numeric keypad from here cause keypress should\n      // be able to detect the keys from the character\n      if (key > 95 && key < 112) {\n        continue\n      }\n\n      if (SPECIAL_KEYS_MAP.hasOwnProperty(key)) {\n        constructor.REVERSE_MAP[SPECIAL_KEYS_MAP[key]] = key\n      }\n    }\n  }\n  return constructor.REVERSE_MAP\n}\n\n},{\"../../helpers/special-keys-map\":32}],13:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * handles a character key event\n *\n * @param {string} character\n * @param {Array} modifiers\n * @param {Event} e\n * @returns void\n */\nmodule.exports = function (character, modifiers, e) {\n  var self = this\n  var callbacks\n  var j\n  var doNotReset = {}\n  var maxLevel = 0\n  var processedSequenceCallback = false\n  var isModifier\n  var ignoreThisKeypress\n\n  callbacks = self.getMatches(character, modifiers, e)\n  // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n  for (j = 0; j < callbacks.length; ++j) {\n    if (callbacks[j].seq) {\n      maxLevel = Math.max(maxLevel, callbacks[j].level)\n    }\n  }\n\n  // loop through matching callbacks for this key event\n  for (j = 0; j < callbacks.length; ++j) {\n    // fire for all sequence callbacks\n    // this is because if for example you have multiple sequences\n    // bound such as \"g i\" and \"g t\" they both need to fire the\n    // callback for matching g cause otherwise you can only ever\n    // match the first one\n    if (callbacks[j].seq) {\n      // only fire callbacks for the maxLevel to prevent\n      // subsequences from also firing\n      //\n      // for example 'a option b' should not cause 'option b' to fire\n      // even though 'option b' is part of the other sequence\n      //\n      // any sequences that do not match here will be discarded\n      // below by the resetSequences call\n      if (callbacks[j].level !== maxLevel) {\n        continue\n      }\n\n      processedSequenceCallback = true\n\n      // keep a list of which sequences were matches for later\n      doNotReset[callbacks[j].seq] = 1\n      self.fireCallback(callbacks[j].callback, e, callbacks[j].combo, callbacks[j].seq)\n      continue\n    }\n\n    // if there were no sequence matches but we are still here\n    // that means this is a regular match so we should fire that\n    if (!processedSequenceCallback) {\n      self.fireCallback(callbacks[j].callback, e, callbacks[j].combo)\n    }\n  }\n\n  // if the key you pressed matches the type of sequence without\n  // being a modifier (ie \"keyup\" or \"keypress\") then we should\n  // reset all sequences that were not matched by this event\n  //\n  // this is so, for example, if you have the sequence \"h a t\" and you\n  // type \"h e a r t\" it does not match.  in this case the \"e\" will\n  // cause the sequence to reset\n  //\n  // modifier keys are ignored because you can have a sequence\n  // that contains modifiers such as \"enter ctrl+space\" and in most\n  // cases the modifier key will be pressed before the next key\n  //\n  // also if you have a sequence such as \"ctrl+b a\" then pressing the\n  // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n  //\n  // the \"keydown\" is expected when there is a modifier, but the\n  // \"keypress\" ends up matching the nextExpectedAction since it occurs\n  // after and that causes the sequence to reset\n  //\n  // we ignore keypresses in a sequence that directly follow a keydown\n  // for the same character\n  ignoreThisKeypress = e.type === 'keypress' && self.ignoreNextKeypress\n  isModifier = require('../../helpers/isModifier')\n  if (e.type === self.nextExpectedAction && !isModifier(character) && !ignoreThisKeypress) {\n    self.resetSequences(doNotReset)\n  }\n\n  self.ignoreNextKeypress = processedSequenceCallback && e.type === 'keydown'\n}\n\n},{\"../../helpers/isModifier\":26}],14:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * handles a keydown event\n *\n * @param {Event} e\n * @returns void\n */\nmodule.exports = function (e) {\n  var self = this\n  var characterFromEvent\n  var eventModifiers\n\n  // normalize e.which for key events\n  // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n  if (typeof e.which !== 'number') {\n    e.which = e.keyCode\n  }\n  characterFromEvent = require('../../helpers/characterFromEvent')\n  var character = characterFromEvent(e)\n\n  // no character found then stop\n  if (!character) {\n    return\n  }\n\n  // need to use === for the character check because the character can be 0\n  if (e.type === 'keyup' && self.ignoreNextKeyup === character) {\n    self.ignoreNextKeyup = false\n    return\n  }\n\n  eventModifiers = require('../../helpers/eventModifiers')\n  self.handleKey(character, eventModifiers(e), e)\n}\n\n},{\"../../helpers/characterFromEvent\":24,\"../../helpers/eventModifiers\":25}],15:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * checks if two arrays are equal\n *\n * @param {Array} modifiers1\n * @param {Array} modifiers2\n * @returns {boolean}\n */\nmodule.exports = function (modifiers1, modifiers2) {\n  return modifiers1.sort().join(',') === modifiers2.sort().join(',')\n}\n\n},{}],16:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * picks the best action based on the key combination\n *\n * @param {string} key - character for key\n * @param {Array} modifiers\n * @param {string=} action passed in\n */\nmodule.exports = function (key, modifiers, action) {\n  var self = this\n\n  // if no action was picked in we should try to pick the one\n  // that we think would work best for this key\n  if (!action) {\n    action = self.getReverseMap()[key] ? 'keydown' : 'keypress'\n  }\n\n  // modifier keys don't work as expected with keypress,\n  // switch to keydown\n  if (action === 'keypress' && modifiers.length) {\n    action = 'keydown'\n  }\n\n  return action\n}\n\n},{}],17:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * resets the library back to its initial state. This is useful\n * if you want to clear out the current keyboard shortcuts and bind\n * new ones - for example if you switch to another page\n *\n * @returns void\n */\nmodule.exports = function () {\n  var self = this\n  self.callbacks = {}\n  self.directMap = {}\n  return this\n}\n\n},{}],18:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n/**\n * called to set a 1 second timeout on the specified sequence\n *\n * this is so after each key press in the sequence you have 1 second\n * to press the next key before you have to start over\n *\n * @returns void\n */\nmodule.exports = function () {\n  var self = this\n\n  clearTimeout(self.resetTimer)\n  self.resetTimer = setTimeout(\n    function () {\n      self.resetSequences()\n    },\n    1000\n  )\n}\n\n},{}],19:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * resets all sequence counters except for the ones passed in\n *\n * @param {Object} doNotReset\n * @returns void\n */\nmodule.exports = function (doNotReset) {\n  var self = this\n\n  doNotReset = doNotReset || {}\n\n  var activeSequences = false\n  var key\n\n  for (key in self.sequenceLevels) {\n    if (doNotReset[key]) {\n      activeSequences = true\n      continue\n    }\n    self.sequenceLevels[key] = 0\n  }\n\n  if (!activeSequences) {\n    self.nextExpectedAction = false\n  }\n}\n\n},{}],20:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n* should we stop this event before firing off callbacks\n*\n* @param {Event} e\n* @param {Element} element\n* @return {boolean}\n*/\nmodule.exports = function (e, element) {\n  // if the element has the class \"combokeys\" then no need to stop\n  if ((' ' + element.className + ' ').indexOf(' combokeys ') > -1) {\n    return false\n  }\n\n  var tagName = element.tagName.toLowerCase()\n\n  // stop for input, select, and textarea\n  return tagName === 'input' || tagName === 'select' || tagName === 'textarea' || element.isContentEditable\n}\n\n},{}],21:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n/**\n * triggers an event that has already been bound\n *\n * @param {string} keys\n * @param {string=} action\n * @returns void\n */\nmodule.exports = function (keys, action) {\n  var self = this\n  if (self.directMap[keys + ':' + action]) {\n    self.directMap[keys + ':' + action]({}, keys)\n  }\n  return this\n}\n\n},{}],22:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n/**\n * unbinds an event to Combokeys\n *\n * the unbinding sets the callback function of the specified key combo\n * to an empty function and deletes the corresponding key in the\n * directMap dict.\n *\n * TODO: actually remove this from the callbacks dictionary instead\n * of binding an empty function\n *\n * the keycombo+action has to be exactly the same as\n * it was defined in the bind method\n *\n * @param {string|Array} keys\n * @param {string} action\n * @returns void\n */\nmodule.exports = function (keys, action) {\n  var self = this\n\n  return self.bind(keys, function () {}, action)\n}\n\n},{}],23:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\nmodule.exports = function () {\n  var self = this\n\n  self.instances.forEach(function (combokeys) {\n    combokeys.reset()\n  })\n}\n\n},{}],24:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * takes the event and returns the key character\n *\n * @param {Event} e\n * @return {string}\n */\nmodule.exports = function (e) {\n  var SPECIAL_KEYS_MAP,\n    SPECIAL_CHARACTERS_MAP\n  SPECIAL_KEYS_MAP = require('./special-keys-map')\n  SPECIAL_CHARACTERS_MAP = require('./special-characters-map')\n\n  // for keypress events we should return the character as is\n  if (e.type === 'keypress') {\n    var character = String.fromCharCode(e.which)\n\n    // if the shift key is not pressed then it is safe to assume\n    // that we want the character to be lowercase.  this means if\n    // you accidentally have caps lock on then your key bindings\n    // will continue to work\n    //\n    // the only side effect that might not be desired is if you\n    // bind something like 'A' cause you want to trigger an\n    // event when capital A is pressed caps lock will no longer\n    // trigger the event.  shift+a will though.\n    if (!e.shiftKey) {\n      character = character.toLowerCase()\n    }\n\n    return character\n  }\n\n  // for non keypress events the special maps are needed\n  if (SPECIAL_KEYS_MAP[e.which]) {\n    return SPECIAL_KEYS_MAP[e.which]\n  }\n\n  if (SPECIAL_CHARACTERS_MAP[e.which]) {\n    return SPECIAL_CHARACTERS_MAP[e.which]\n  }\n\n  // if it is not in the special map\n\n  // with keydown and keyup events the character seems to always\n  // come in as an uppercase character whether you are pressing shift\n  // or not.  we should make sure it is always lowercase for comparisons\n  return String.fromCharCode(e.which).toLowerCase()\n}\n\n},{\"./special-characters-map\":31,\"./special-keys-map\":32}],25:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * takes a key event and figures out what the modifiers are\n *\n * @param {Event} e\n * @returns {Array}\n */\nmodule.exports = function (e) {\n  var modifiers = []\n\n  if (e.shiftKey) {\n    modifiers.push('shift')\n  }\n\n  if (e.altKey) {\n    modifiers.push('alt')\n  }\n\n  if (e.ctrlKey) {\n    modifiers.push('ctrl')\n  }\n\n  if (e.metaKey) {\n    modifiers.push('meta')\n  }\n\n  return modifiers\n}\n\n},{}],26:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * determines if the keycode specified is a modifier key or not\n *\n * @param {string} key\n * @returns {boolean}\n */\nmodule.exports = function (key) {\n  return key === 'shift' || key === 'ctrl' || key === 'alt' || key === 'meta'\n}\n\n},{}],27:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * Converts from a string key combination to an array\n *\n * @param  {string} combination like \"command+shift+l\"\n * @return {Array}\n */\nmodule.exports = function (combination) {\n  if (combination === '+') {\n    return ['+']\n  }\n\n  return combination.split('+')\n}\n\n},{}],28:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * prevents default for this event\n *\n * @param {Event} e\n * @returns void\n */\nmodule.exports = function (e) {\n  if (e.preventDefault) {\n    e.preventDefault()\n    return\n  }\n\n  e.returnValue = false\n}\n\n},{}],29:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n/**\n * this is a mapping of keys that require shift on a US keypad\n * back to the non shift equivelents\n *\n * this is so you can use keyup events with these keys\n *\n * note that this will only work reliably on US keyboards\n *\n * @type {Object}\n */\nmodule.exports = {\n  '~': '`',\n  '!': '1',\n  '@': '2',\n  '#': '3',\n  '$': '4',\n  '%': '5',\n  '^': '6',\n  '&': '7',\n  '*': '8',\n  '(': '9',\n  ')': '0',\n  '_': '-',\n  '+': '=',\n  ':': ';',\n  '\"': \"'\",\n  '<': ',',\n  '>': '.',\n  '?': '/',\n  '|': '\\\\'\n}\n\n},{}],30:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n/**\n * this is a list of special strings you can use to map\n * to modifier keys when you specify your keyboard shortcuts\n *\n * @type {Object}\n */\nmodule.exports = {\n  'option': 'alt',\n  'command': 'meta',\n  'return': 'enter',\n  'escape': 'esc',\n  'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n}\n\n},{}],31:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n/**\n * mapping for special characters so they can support\n *\n * this dictionary is only used incase you want to bind a\n * keyup or keydown event to one of these keys\n *\n * @type {Object}\n */\nmodule.exports = {\n  106: '*',\n  107: '+',\n  109: '-',\n  110: '.',\n  111: '/',\n  186: ';',\n  187: '=',\n  188: ',',\n  189: '-',\n  190: '.',\n  191: '/',\n  192: '`',\n  219: '[',\n  220: '\\\\',\n  221: ']',\n  222: \"'\"\n}\n\n},{}],32:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n/**\n * mapping of special keycodes to their corresponding keys\n *\n * everything in this dictionary cannot use keypress events\n * so it has to be here to map to the correct keycodes for\n * keyup/keydown events\n *\n * @type {Object}\n */\nmodule.exports = {\n  8: 'backspace',\n  9: 'tab',\n  13: 'enter',\n  16: 'shift',\n  17: 'ctrl',\n  18: 'alt',\n  20: 'capslock',\n  27: 'esc',\n  32: 'space',\n  33: 'pageup',\n  34: 'pagedown',\n  35: 'end',\n  36: 'home',\n  37: 'left',\n  38: 'up',\n  39: 'right',\n  40: 'down',\n  45: 'ins',\n  46: 'del',\n  91: 'meta',\n  93: 'meta',\n  187: 'plus',\n  189: 'minus',\n  224: 'meta'\n}\n\n/**\n * loop through the f keys, f1 to f19 and add them to the map\n * programatically\n */\nfor (var i = 1; i < 20; ++i) {\n  module.exports[111 + i] = 'f' + i\n}\n\n/**\n * loop through to map numbers on the numeric keypad\n */\nfor (i = 0; i <= 9; ++i) {\n  module.exports[i + 96] = i\n}\n\n},{}],33:[function(require,module,exports){\n/* eslint-env node, browser */\n'use strict'\n\n/**\n * stops propogation for this event\n *\n * @param {Event} e\n * @returns void\n */\nmodule.exports = function (e) {\n  if (e.stopPropagation) {\n    e.stopPropagation()\n    return\n  }\n\n  e.cancelBubble = true\n}\n\n},{}],34:[function(require,module,exports){\nvar draw = require('./draw');\r\nvar kb = require('./keyboard');\r\nvar pattern = require('./pattern');\r\n\r\nvar menuCanvas = document.getElementById('menuCanvas');\r\nvar m = menuCanvas.getContext('2d');\r\nmenuCanvas.width = 512;\r\nmenuCanvas.height = 32;\r\nvar m = menuCanvas.getContext('2d');\r\n\r\nvar gameCanvas = document.getElementById('gameCanvas');\r\ngameCanvas.width = 512;\r\ngameCanvas.height = 512;\r\nvar g = gameCanvas.getContext('2d');\r\n\r\nfunction vec2(x,y) {\r\n\treturn { x: x, y: y };\r\n}\r\n\r\nfunction randColor() {\r\n\treturn '#' + Math.floor(Math.random()*16777215).toString(16);\r\n}\r\n\r\nfunction randInt(min, max) {\r\n\treturn Math.round(Math.random() * max) - min;\r\n}\r\n\r\nvar player = {\r\n\ttype: 'player',\r\n\tpos: vec2(gameCanvas.width/2, gameCanvas.height/2),\r\n\tradius: 5,\r\n\tspeed: 3,\r\n\tdeinc: 0.1,\r\n\tcolor: '#333'\r\n};\r\n\r\nvar bullets = { array: [] };\r\n\r\nfunction addBullet(bulletObject) {\r\n\tbullets.array.push(bulletObject);\r\n}\r\n\r\nfunction randomBoundBullet() {\r\n\tif(Math.random() >= 0.5) {\r\n\t\treturn vec2(randInt(0,gameCanvas.width),0);\r\n\t} else {\r\n\t\treturn vec2(0,randInt(0,gameCanvas.height));\r\n\t}\r\n}\r\n\r\nvar func = {\r\n\tapplyPlayerSpeed: function(obj) {\r\n\t\tif(player.speed > 0) {\r\n\t\t\tif(kb.up)    obj.pos.y -= player.speed;\r\n\t\t\tif(kb.down)  obj.pos.y += player.speed;\r\n\t\t\tif(kb.right) obj.pos.x += player.speed;\r\n\t\t\tif(kb.left)  obj.pos.x -= player.speed;\r\n\t\t}\r\n\t},\r\n\tpytha: function(pos1, pos2) {\r\n\t\treturn Math.sqrt(\r\n\t\t\t((pos1.x - pos2.x) * (pos1.x - pos2.x)) +\r\n\t\t\t((pos1.y - pos2.y) * (pos1.y - pos2.y))\r\n\t\t);\r\n\t},\r\n\tdistanceCheck: function(obj1, obj2) {\r\n\t\tpytha = func.pytha(obj1.pos, obj2.pos);\r\n\t\treturn pytha < (obj1.radius + obj2.radius);\r\n\t},\r\n\r\n\tunclog: function(obj1, obj2) {\r\n\t\tvar angle = Math.acos((obj1.pos.x - obj2.pos.x)/func.pytha(obj1.pos, obj2.pos));\r\n\t\tobj2.pos.x = obj1.pos.x - (Math.cos(angle) * (obj1.radius + obj2.radius));\r\n\r\n\t\tif(obj2.pos.y < obj1.pos.y) {\r\n\t\t\tobj2.pos.y = obj1.pos.y - (Math.sin(angle) * (obj1.radius + obj2.radius));\r\n\t\t} else {\r\n\t\t\tobj2.pos.y = obj1.pos.y + (Math.sin(angle) * (obj1.radius + obj2.radius));\r\n\t\t}\r\n\t},\r\n\r\n\tsquareCheck: function(obj1, obj2) {\r\n\t\treturn !(\r\n\t\t\t(obj1.pos.x + obj1.radius) < (obj2.pos.x - obj2.radius) ||\r\n\t\t\t(obj1.pos.y + obj1.radius) < (obj2.pos.y - obj2.radius) ||\r\n\t\t\t(obj1.pos.x - obj1.radius) > (obj2.pos.x + obj2.radius) ||\r\n\t\t\t(obj1.pos.y - obj1.radius) > (obj2.pos.y + obj2.radius)\r\n\t\t);\r\n\t}\r\n};\r\n\r\nvar update = {\r\n\tcollision: function(bullet) {\r\n\t\tif(bullet.isConnected) {\r\n\t\t\t// Connected Collision\r\n\t\t\tfor(var b=0, len = bullets.array.length; b < len; b++) {\r\n\t\t\t\tvar otherBullet = bullets.array[b];\r\n\t\t\t\tif(!otherBullet.isConnected && func.squareCheck(bullet, otherBullet) && func.distanceCheck(bullet, otherBullet)) {\r\n\r\n\t\t\t\t\tfunc.unclog(bullet, otherBullet);\r\n\t\t\t\t\totherBullet.isConnected = true;\r\n\t\t\t\t\tplayer.speed -= otherBullet.radius / 120;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Player Collision\r\n\t\t\tif(func.squareCheck(player, bullet) && func.distanceCheck(player, bullet)) {\r\n\t\t\t\tfunc.unclog(player, bullet);\r\n\r\n\t\t\t\tbullet.isConnected = true;\r\n\t\t\t\tplayer.speed -= bullet.radius / 120;\r\n\t\t\t} else {\r\n\t\t\t\tbullet.pattern(bullet, frame);\r\n\t\t\t\tupdate.swapArround(bullet);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tswapArround: function(obj) {\r\n\t\tif(obj.pos.y < gameCanvas.height * -0.1) obj.pos.y += gameCanvas.height * 1.2;\r\n\t\tif(obj.pos.y > gameCanvas.height * 1.1)  obj.pos.y -= gameCanvas.height * 1.2;\r\n\r\n\t\tif(obj.pos.x > gameCanvas.width * 1.1)   obj.pos.x -= gameCanvas.height * 1.2;\r\n\t\tif(obj.pos.x < gameCanvas.width * -0.1)  obj.pos.x += gameCanvas.height * 1.2;\r\n\t}\r\n};\r\n\r\nvar frame = -1;\r\nvar loop = {\r\n\tmenu: function() {\r\n\t\tframe++;\r\n\r\n\t\trequestAnimationFrame(loop.cur);\r\n\t},\r\n\tgame: function() {\r\n\t\tframe++;\r\n\r\n\t\tdraw.clear(g, gameCanvas);\r\n\r\n\t\tfunc.applyPlayerSpeed(player);\r\n\t\tupdate.swapArround(player);\r\n\t\tdraw.circle(g,player.pos, player.radius, player.color);\r\n\r\n\t\tfor(var i=0, len = bullets.array.length; i < len; i++) {\r\n\t\t\tvar bullet = bullets.array[i];\r\n\t\t\tbullet.xspeed += 0.0005;\r\n\t\t\tbullet.yspeed += 0.0005;\r\n\r\n\t\t\tif(bullet.isConnected) {\r\n\t\t\t\tfunc.applyPlayerSpeed(bullet);\r\n\t\t\t}\r\n\r\n\t\t\tupdate.collision(bullet, i);\r\n\t\t\tdraw.circle(g,bullet.pos,bullet.radius,bullet.color);\r\n\t\t}\r\n\r\n\t\tif(frame % 60 === 0) {\r\n\t\t\taddBullet({\r\n\t\t\t\tpos: \t\t\trandomBoundBullet(),\r\n\t\t\t\tradius: \t6 + randInt(0,8),\r\n\t\t\t\tcolor: \t\trandColor(),\r\n\t\t\t\tspeedpos: vec2(1 + (2 * Math.random()), 1 + (2 * Math.random())),\r\n\t\t\t\tpattern: pattern.wavyDown\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tdraw.clear(m, menuCanvas);\r\n\r\n\t\trequestAnimationFrame(loop.cur);\r\n\t}\r\n};\r\nloop.cur = loop.game;\r\nloop.cur();\r\n\n},{\"./draw\":35,\"./keyboard\":36,\"./pattern\":37}],35:[function(require,module,exports){\nmodule.exports = {\r\n\tcircle: function(ctx,pos,radius,color) {\r\n\t\tctx.fillStyle = color;\r\n\t\tctx.beginPath();\r\n\t\tctx.arc(pos.x, pos.y, radius, 0, 2*Math.PI);\r\n\t\tctx.fill();\r\n\t},\r\n\tline: function(ctx,pos1,pos2,width,color) {\r\n\t\tctx.beginPath();\r\n\t\tctx.moveTo(pos1.x, pos1.y);\r\n\t\tctx.lineTo(pos2.x, pos2.y);\r\n\t\tctx.lineWidth = width;\r\n\t\tctx.strokeStyle = color;\r\n\t\tctx.stroke();\r\n\t},\r\n\tclear: function(ctx, canvas) {\r\n\t\tctx.fillStyle = 'white';\r\n\t\tctx.fillRect(0,0,canvas.width, canvas.height);\r\n\t},\r\n\r\n\ttext: function(ctx,text,size,color,pos) {\r\n\t\tctx.fillStyle = color;\r\n\t\tctx.font = size.toString() + 'px Helvetica';\r\n\t\tctx.fillText(text, pos.x, pos.y);\r\n\t},\r\n\tmenu: function() {\r\n\t\t// TODO\r\n\t}\r\n};\r\n\n},{}],36:[function(require,module,exports){\nvar Combokeys = require('combokeys');\nvar canvasInput = new Combokeys(document.documentElement);\n\nvar kb = {\n\tup: false, down: false, left: false, right: false\n};\n\ncanvasInput.bind('up', function() { kb.up = true; }, 'keydown');\ncanvasInput.bind('up', function() { kb.up = false; }, 'keyup');\ncanvasInput.bind('down', function() { kb.down = true; }, 'keydown');\ncanvasInput.bind('down', function() { kb.down = false; }, 'keyup');\ncanvasInput.bind('left', function() { kb.left = true; }, 'keydown');\ncanvasInput.bind('left', function() { kb.left = false; }, 'keyup');\ncanvasInput.bind('right', function() { kb.right = true; }, 'keydown');\ncanvasInput.bind('right', function() { kb.right = false; }, 'keyup');\n\nmodule.exports = kb;\n\n},{\"combokeys\":1}],37:[function(require,module,exports){\nmodule.exports = {\r\n\tdown: function(bullet) {\r\n\t\tbullet.pos.y += bullet.speedpos.y;\r\n\t},\r\n\tsideWays: function(bullet) {\r\n\t\tbullet.pos.y += bullet.speedpos.y;\r\n\t\tbullet.pos.x += bullet.speedpos.x;\r\n\t},\r\n\twavyDown: function(bullet, frame) {\r\n\t\tbullet.pos.y += bullet.speedpos.y + Math.sin((frame)/30);\r\n\t\tbullet.pos.x += Math.sin(frame/(bullet.speedpos.x * 40)) * 2;\r\n\t},\r\n\tawayFromCenter: function(bullet, key) {\r\n    // TODO\r\n\t}\r\n};\r\n\n},{}]},{},[34])\n\n","/* eslint-env node, browser */\n'use strict'\nmodule.exports = function () {\n  var self = this\n  var on = require('./dom-event')\n  var element = self.element\n\n  self.eventHandler = require('./handleKeyEvent').bind(self)\n\n  on(element, 'keypress', self.eventHandler)\n  on(element, 'keydown', self.eventHandler)\n  on(element, 'keyup', self.eventHandler)\n}\n","/* eslint-env node, browser */\n'use strict'\n/**\n * binds an event to Combokeys\n *\n * can be a single key, a combination of keys separated with +,\n * an array of keys, or a sequence of keys separated by spaces\n *\n * be sure to list the modifier keys first to make sure that the\n * correct key ends up getting bound (the last key in the pattern)\n *\n * @param {string|Array} keys\n * @param {Function} callback\n * @param {string=} action - \"keypress\", \"keydown\", or \"keyup\"\n * @returns void\n */\nmodule.exports = function (keys, callback, action) {\n  var self = this\n\n  keys = keys instanceof Array ? keys : [keys]\n  self.bindMultiple(keys, callback, action)\n  return self\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * binds multiple combinations to the same callback\n *\n * @param {Array} combinations\n * @param {Function} callback\n * @param {string|undefined} action\n * @returns void\n */\nmodule.exports = function (combinations, callback, action) {\n  var self = this\n\n  for (var j = 0; j < combinations.length; ++j) {\n    self.bindSingle(combinations[j], callback, action)\n  }\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * binds a key sequence to an event\n *\n * @param {string} combo - combo specified in bind call\n * @param {Array} keys\n * @param {Function} callback\n * @param {string=} action\n * @returns void\n */\nmodule.exports = function (combo, keys, callback, action) {\n  var self = this\n\n  // start off by adding a sequence level record for this combination\n  // and setting the level to 0\n  self.sequenceLevels[combo] = 0\n\n  /**\n   * callback to increase the sequence level for this sequence and reset\n   * all other sequences that were active\n   *\n   * @param {string} nextAction\n   * @returns {Function}\n   */\n  function increaseSequence (nextAction) {\n    return function () {\n      self.nextExpectedAction = nextAction\n      ++self.sequenceLevels[combo]\n      self.resetSequenceTimer()\n    }\n  }\n\n  /**\n   * wraps the specified callback inside of another function in order\n   * to reset all sequence counters as soon as this sequence is done\n   *\n   * @param {Event} e\n   * @returns void\n   */\n  function callbackAndReset (e) {\n    var characterFromEvent\n    self.fireCallback(callback, e, combo)\n\n    // we should ignore the next key up if the action is key down\n    // or keypress.  this is so if you finish a sequence and\n    // release the key the final key will not trigger a keyup\n    if (action !== 'keyup') {\n      characterFromEvent = require('../../helpers/characterFromEvent')\n      self.ignoreNextKeyup = characterFromEvent(e)\n    }\n\n    // weird race condition if a sequence ends with the key\n    // another sequence begins with\n    setTimeout(\n      function () {\n        self.resetSequences()\n      },\n      10\n    )\n  }\n\n  // loop through keys one at a time and bind the appropriate callback\n  // function.  for any key leading up to the final one it should\n  // increase the sequence. after the final, it should reset all sequences\n  //\n  // if an action is specified in the original bind call then that will\n  // be used throughout.  otherwise we will pass the action that the\n  // next key in the sequence should match.  this allows a sequence\n  // to mix and match keypress and keydown events depending on which\n  // ones are better suited to the key provided\n  for (var j = 0; j < keys.length; ++j) {\n    var isFinal = j + 1 === keys.length\n    var wrappedCallback = isFinal ? callbackAndReset : increaseSequence(action || self.getKeyInfo(keys[j + 1]).action)\n    self.bindSingle(keys[j], wrappedCallback, action, combo, j)\n  }\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * binds a single keyboard combination\n *\n * @param {string} combination\n * @param {Function} callback\n * @param {string=} action\n * @param {string=} sequenceName - name of sequence if part of sequence\n * @param {number=} level - what part of the sequence the command is\n * @returns void\n */\nmodule.exports = function (combination, callback, action, sequenceName, level) {\n  var self = this\n\n  // store a direct mapped reference for use with Combokeys.trigger\n  self.directMap[combination + ':' + action] = callback\n\n  // make sure multiple spaces in a row become a single space\n  combination = combination.replace(/\\s+/g, ' ')\n\n  var sequence = combination.split(' ')\n  var info\n\n  // if this pattern is a sequence of keys then run through this method\n  // to reprocess each pattern one key at a time\n  if (sequence.length > 1) {\n    self.bindSequence(combination, sequence, callback, action)\n    return\n  }\n\n  info = self.getKeyInfo(combination, action)\n\n  // make sure to initialize array if this is the first time\n  // a callback is added for this key\n  self.callbacks[info.key] = self.callbacks[info.key] || []\n\n  // remove an existing match if there is one\n  self.getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level)\n\n  // add this call back to the array\n  // if it is a sequence put it at the beginning\n  // if not put it at the end\n  //\n  // this is important because the way these are processed expects\n  // the sequence ones to come first\n  self.callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n    callback: callback,\n    modifiers: info.modifiers,\n    action: info.action,\n    seq: sequenceName,\n    level: level,\n    combo: combination\n  })\n}\n","var off = require('./dom-event').off\nmodule.exports = function () {\n  var self = this\n  var element = self.element\n\n  off(element, 'keypress', self.eventHandler)\n  off(element, 'keydown', self.eventHandler)\n  off(element, 'keyup', self.eventHandler)\n}\n","module.exports = on\nmodule.exports.on = on\nmodule.exports.off = off\n\nfunction on (element, event, callback, capture) {\n  !element.addEventListener && (event = 'on' + event)\n  ;(element.addEventListener || element.attachEvent).call(element, event, callback, capture)\n  return callback\n}\n\nfunction off (element, event, callback, capture) {\n  !element.removeEventListener && (event = 'on' + event)\n  ;(element.removeEventListener || element.detachEvent).call(element, event, callback, capture)\n  return callback\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * actually calls the callback function\n *\n * if your callback function returns false this will use the jquery\n * convention - prevent default and stop propogation on the event\n *\n * @param {Function} callback\n * @param {Event} e\n * @returns void\n */\nmodule.exports = function (callback, e, combo, sequence) {\n  var self = this\n  var preventDefault\n  var stopPropagation\n\n  // if this event should not happen stop here\n  if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n    return\n  }\n\n  if (callback(e, combo) === false) {\n    preventDefault = require('../../helpers/preventDefault')\n    preventDefault(e)\n    stopPropagation = require('../../helpers/stopPropagation')\n    stopPropagation(e)\n  }\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * Gets info for a specific key combination\n *\n * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n * @param  {string=} action\n * @returns {Object}\n */\nmodule.exports = function (combination, action) {\n  var self = this\n  var keysFromString\n  var keys\n  var key\n  var j\n  var modifiers = []\n  var SPECIAL_ALIASES\n  var SHIFT_MAP\n  var isModifier\n\n  keysFromString = require('../../helpers/keysFromString')\n  // take the keys from this pattern and figure out what the actual\n  // pattern is all about\n  keys = keysFromString(combination)\n\n  SPECIAL_ALIASES = require('../../helpers/special-aliases')\n  SHIFT_MAP = require('../../helpers/shift-map')\n  isModifier = require('../../helpers/isModifier')\n  for (j = 0; j < keys.length; ++j) {\n    key = keys[j]\n\n    // normalize key names\n    if (SPECIAL_ALIASES[key]) {\n      key = SPECIAL_ALIASES[key]\n    }\n\n    // if this is not a keypress event then we should\n    // be smart about using shift keys\n    // this will only work for US keyboards however\n    if (action && action !== 'keypress' && SHIFT_MAP[key]) {\n      key = SHIFT_MAP[key]\n      modifiers.push('shift')\n    }\n\n    // if this key is a modifier then add it to the list of modifiers\n    if (isModifier(key)) {\n      modifiers.push(key)\n    }\n  }\n\n  // depending on what the key combination is\n  // we will try to pick the best event for it\n  action = self.pickBestAction(key, modifiers, action)\n\n  return {\n    key: key,\n    modifiers: modifiers,\n    action: action\n  }\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * finds all callbacks that match based on the keycode, modifiers,\n * and action\n *\n * @param {string} character\n * @param {Array} modifiers\n * @param {Event|Object} e\n * @param {string=} sequenceName - name of the sequence we are looking for\n * @param {string=} combination\n * @param {number=} level\n * @returns {Array}\n */\nmodule.exports = function (character, modifiers, e, sequenceName, combination, level) {\n  var self = this\n  var j\n  var callback\n  var matches = []\n  var action = e.type\n  var isModifier\n  var modifiersMatch\n\n  if (\n      action === 'keypress' &&\n      // Firefox fires keypress for arrows\n      !(e.code && e.code.slice(0, 5) === 'Arrow')\n  ) {\n    // 'any-character' callbacks are only on `keypress`\n    var anyCharCallbacks = self.callbacks['any-character'] || []\n    anyCharCallbacks.forEach(function (callback) {\n      matches.push(callback)\n    })\n  }\n\n  if (!self.callbacks[character]) { return matches }\n\n  isModifier = require('../../helpers/isModifier')\n  // if a modifier key is coming up on its own we should allow it\n  if (action === 'keyup' && isModifier(character)) {\n    modifiers = [character]\n  }\n\n  // loop through all callbacks for the key that was pressed\n  // and see if any of them match\n  for (j = 0; j < self.callbacks[character].length; ++j) {\n    callback = self.callbacks[character][j]\n\n    // if a sequence name is not specified, but this is a sequence at\n    // the wrong level then move onto the next match\n    if (!sequenceName && callback.seq && self.sequenceLevels[callback.seq] !== callback.level) {\n      continue\n    }\n\n    // if the action we are looking for doesn't match the action we got\n    // then we should keep going\n    if (action !== callback.action) {\n      continue\n    }\n\n    // if this is a keypress event and the meta key and control key\n    // are not pressed that means that we need to only look at the\n    // character, otherwise check the modifiers as well\n    //\n    // chrome will not fire a keypress if meta or control is down\n    // safari will fire a keypress if meta or meta+shift is down\n    // firefox will fire a keypress if meta or control is down\n    modifiersMatch = require('./modifiersMatch')\n    if ((action === 'keypress' && !e.metaKey && !e.ctrlKey) || modifiersMatch(modifiers, callback.modifiers)) {\n      // when you bind a combination or sequence a second time it\n      // should overwrite the first one.  if a sequenceName or\n      // combination is specified in this call it does just that\n      //\n      // @todo make deleting its own method?\n      var deleteCombo = !sequenceName && callback.combo === combination\n      var deleteSequence = sequenceName && callback.seq === sequenceName && callback.level === level\n      if (deleteCombo || deleteSequence) {\n        self.callbacks[character].splice(j, 1)\n      }\n\n      matches.push(callback)\n    }\n  }\n\n  return matches\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * reverses the map lookup so that we can look for specific keys\n * to see what can and can't use keypress\n *\n * @return {Object}\n */\nmodule.exports = function () {\n  var self = this\n  var constructor = self.constructor\n  var SPECIAL_KEYS_MAP\n\n  if (!constructor.REVERSE_MAP) {\n    constructor.REVERSE_MAP = {}\n    SPECIAL_KEYS_MAP = require('../../helpers/special-keys-map')\n    for (var key in SPECIAL_KEYS_MAP) {\n      // pull out the numeric keypad from here cause keypress should\n      // be able to detect the keys from the character\n      if (key > 95 && key < 112) {\n        continue\n      }\n\n      if (SPECIAL_KEYS_MAP.hasOwnProperty(key)) {\n        constructor.REVERSE_MAP[SPECIAL_KEYS_MAP[key]] = key\n      }\n    }\n  }\n  return constructor.REVERSE_MAP\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * handles a character key event\n *\n * @param {string} character\n * @param {Array} modifiers\n * @param {Event} e\n * @returns void\n */\nmodule.exports = function (character, modifiers, e) {\n  var self = this\n  var callbacks\n  var j\n  var doNotReset = {}\n  var maxLevel = 0\n  var processedSequenceCallback = false\n  var isModifier\n  var ignoreThisKeypress\n\n  callbacks = self.getMatches(character, modifiers, e)\n  // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n  for (j = 0; j < callbacks.length; ++j) {\n    if (callbacks[j].seq) {\n      maxLevel = Math.max(maxLevel, callbacks[j].level)\n    }\n  }\n\n  // loop through matching callbacks for this key event\n  for (j = 0; j < callbacks.length; ++j) {\n    // fire for all sequence callbacks\n    // this is because if for example you have multiple sequences\n    // bound such as \"g i\" and \"g t\" they both need to fire the\n    // callback for matching g cause otherwise you can only ever\n    // match the first one\n    if (callbacks[j].seq) {\n      // only fire callbacks for the maxLevel to prevent\n      // subsequences from also firing\n      //\n      // for example 'a option b' should not cause 'option b' to fire\n      // even though 'option b' is part of the other sequence\n      //\n      // any sequences that do not match here will be discarded\n      // below by the resetSequences call\n      if (callbacks[j].level !== maxLevel) {\n        continue\n      }\n\n      processedSequenceCallback = true\n\n      // keep a list of which sequences were matches for later\n      doNotReset[callbacks[j].seq] = 1\n      self.fireCallback(callbacks[j].callback, e, callbacks[j].combo, callbacks[j].seq)\n      continue\n    }\n\n    // if there were no sequence matches but we are still here\n    // that means this is a regular match so we should fire that\n    if (!processedSequenceCallback) {\n      self.fireCallback(callbacks[j].callback, e, callbacks[j].combo)\n    }\n  }\n\n  // if the key you pressed matches the type of sequence without\n  // being a modifier (ie \"keyup\" or \"keypress\") then we should\n  // reset all sequences that were not matched by this event\n  //\n  // this is so, for example, if you have the sequence \"h a t\" and you\n  // type \"h e a r t\" it does not match.  in this case the \"e\" will\n  // cause the sequence to reset\n  //\n  // modifier keys are ignored because you can have a sequence\n  // that contains modifiers such as \"enter ctrl+space\" and in most\n  // cases the modifier key will be pressed before the next key\n  //\n  // also if you have a sequence such as \"ctrl+b a\" then pressing the\n  // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n  //\n  // the \"keydown\" is expected when there is a modifier, but the\n  // \"keypress\" ends up matching the nextExpectedAction since it occurs\n  // after and that causes the sequence to reset\n  //\n  // we ignore keypresses in a sequence that directly follow a keydown\n  // for the same character\n  ignoreThisKeypress = e.type === 'keypress' && self.ignoreNextKeypress\n  isModifier = require('../../helpers/isModifier')\n  if (e.type === self.nextExpectedAction && !isModifier(character) && !ignoreThisKeypress) {\n    self.resetSequences(doNotReset)\n  }\n\n  self.ignoreNextKeypress = processedSequenceCallback && e.type === 'keydown'\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * handles a keydown event\n *\n * @param {Event} e\n * @returns void\n */\nmodule.exports = function (e) {\n  var self = this\n  var characterFromEvent\n  var eventModifiers\n\n  // normalize e.which for key events\n  // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n  if (typeof e.which !== 'number') {\n    e.which = e.keyCode\n  }\n  characterFromEvent = require('../../helpers/characterFromEvent')\n  var character = characterFromEvent(e)\n\n  // no character found then stop\n  if (!character) {\n    return\n  }\n\n  // need to use === for the character check because the character can be 0\n  if (e.type === 'keyup' && self.ignoreNextKeyup === character) {\n    self.ignoreNextKeyup = false\n    return\n  }\n\n  eventModifiers = require('../../helpers/eventModifiers')\n  self.handleKey(character, eventModifiers(e), e)\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * checks if two arrays are equal\n *\n * @param {Array} modifiers1\n * @param {Array} modifiers2\n * @returns {boolean}\n */\nmodule.exports = function (modifiers1, modifiers2) {\n  return modifiers1.sort().join(',') === modifiers2.sort().join(',')\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * picks the best action based on the key combination\n *\n * @param {string} key - character for key\n * @param {Array} modifiers\n * @param {string=} action passed in\n */\nmodule.exports = function (key, modifiers, action) {\n  var self = this\n\n  // if no action was picked in we should try to pick the one\n  // that we think would work best for this key\n  if (!action) {\n    action = self.getReverseMap()[key] ? 'keydown' : 'keypress'\n  }\n\n  // modifier keys don't work as expected with keypress,\n  // switch to keydown\n  if (action === 'keypress' && modifiers.length) {\n    action = 'keydown'\n  }\n\n  return action\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * resets the library back to its initial state. This is useful\n * if you want to clear out the current keyboard shortcuts and bind\n * new ones - for example if you switch to another page\n *\n * @returns void\n */\nmodule.exports = function () {\n  var self = this\n  self.callbacks = {}\n  self.directMap = {}\n  return this\n}\n","/* eslint-env node, browser */\n'use strict'\n/**\n * called to set a 1 second timeout on the specified sequence\n *\n * this is so after each key press in the sequence you have 1 second\n * to press the next key before you have to start over\n *\n * @returns void\n */\nmodule.exports = function () {\n  var self = this\n\n  clearTimeout(self.resetTimer)\n  self.resetTimer = setTimeout(\n    function () {\n      self.resetSequences()\n    },\n    1000\n  )\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * resets all sequence counters except for the ones passed in\n *\n * @param {Object} doNotReset\n * @returns void\n */\nmodule.exports = function (doNotReset) {\n  var self = this\n\n  doNotReset = doNotReset || {}\n\n  var activeSequences = false\n  var key\n\n  for (key in self.sequenceLevels) {\n    if (doNotReset[key]) {\n      activeSequences = true\n      continue\n    }\n    self.sequenceLevels[key] = 0\n  }\n\n  if (!activeSequences) {\n    self.nextExpectedAction = false\n  }\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n* should we stop this event before firing off callbacks\n*\n* @param {Event} e\n* @param {Element} element\n* @return {boolean}\n*/\nmodule.exports = function (e, element) {\n  // if the element has the class \"combokeys\" then no need to stop\n  if ((' ' + element.className + ' ').indexOf(' combokeys ') > -1) {\n    return false\n  }\n\n  var tagName = element.tagName.toLowerCase()\n\n  // stop for input, select, and textarea\n  return tagName === 'input' || tagName === 'select' || tagName === 'textarea' || element.isContentEditable\n}\n","/* eslint-env node, browser */\n'use strict'\n/**\n * triggers an event that has already been bound\n *\n * @param {string} keys\n * @param {string=} action\n * @returns void\n */\nmodule.exports = function (keys, action) {\n  var self = this\n  if (self.directMap[keys + ':' + action]) {\n    self.directMap[keys + ':' + action]({}, keys)\n  }\n  return this\n}\n","/* eslint-env node, browser */\n'use strict'\n/**\n * unbinds an event to Combokeys\n *\n * the unbinding sets the callback function of the specified key combo\n * to an empty function and deletes the corresponding key in the\n * directMap dict.\n *\n * TODO: actually remove this from the callbacks dictionary instead\n * of binding an empty function\n *\n * the keycombo+action has to be exactly the same as\n * it was defined in the bind method\n *\n * @param {string|Array} keys\n * @param {string} action\n * @returns void\n */\nmodule.exports = function (keys, action) {\n  var self = this\n\n  return self.bind(keys, function () {}, action)\n}\n","/* eslint-env node, browser */\n'use strict'\n\nmodule.exports = function () {\n  var self = this\n\n  self.instances.forEach(function (combokeys) {\n    combokeys.reset()\n  })\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * takes the event and returns the key character\n *\n * @param {Event} e\n * @return {string}\n */\nmodule.exports = function (e) {\n  var SPECIAL_KEYS_MAP,\n    SPECIAL_CHARACTERS_MAP\n  SPECIAL_KEYS_MAP = require('./special-keys-map')\n  SPECIAL_CHARACTERS_MAP = require('./special-characters-map')\n\n  // for keypress events we should return the character as is\n  if (e.type === 'keypress') {\n    var character = String.fromCharCode(e.which)\n\n    // if the shift key is not pressed then it is safe to assume\n    // that we want the character to be lowercase.  this means if\n    // you accidentally have caps lock on then your key bindings\n    // will continue to work\n    //\n    // the only side effect that might not be desired is if you\n    // bind something like 'A' cause you want to trigger an\n    // event when capital A is pressed caps lock will no longer\n    // trigger the event.  shift+a will though.\n    if (!e.shiftKey) {\n      character = character.toLowerCase()\n    }\n\n    return character\n  }\n\n  // for non keypress events the special maps are needed\n  if (SPECIAL_KEYS_MAP[e.which]) {\n    return SPECIAL_KEYS_MAP[e.which]\n  }\n\n  if (SPECIAL_CHARACTERS_MAP[e.which]) {\n    return SPECIAL_CHARACTERS_MAP[e.which]\n  }\n\n  // if it is not in the special map\n\n  // with keydown and keyup events the character seems to always\n  // come in as an uppercase character whether you are pressing shift\n  // or not.  we should make sure it is always lowercase for comparisons\n  return String.fromCharCode(e.which).toLowerCase()\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * takes a key event and figures out what the modifiers are\n *\n * @param {Event} e\n * @returns {Array}\n */\nmodule.exports = function (e) {\n  var modifiers = []\n\n  if (e.shiftKey) {\n    modifiers.push('shift')\n  }\n\n  if (e.altKey) {\n    modifiers.push('alt')\n  }\n\n  if (e.ctrlKey) {\n    modifiers.push('ctrl')\n  }\n\n  if (e.metaKey) {\n    modifiers.push('meta')\n  }\n\n  return modifiers\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * determines if the keycode specified is a modifier key or not\n *\n * @param {string} key\n * @returns {boolean}\n */\nmodule.exports = function (key) {\n  return key === 'shift' || key === 'ctrl' || key === 'alt' || key === 'meta'\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * Converts from a string key combination to an array\n *\n * @param  {string} combination like \"command+shift+l\"\n * @return {Array}\n */\nmodule.exports = function (combination) {\n  if (combination === '+') {\n    return ['+']\n  }\n\n  return combination.split('+')\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * prevents default for this event\n *\n * @param {Event} e\n * @returns void\n */\nmodule.exports = function (e) {\n  if (e.preventDefault) {\n    e.preventDefault()\n    return\n  }\n\n  e.returnValue = false\n}\n","/* eslint-env node, browser */\n'use strict'\n/**\n * this is a mapping of keys that require shift on a US keypad\n * back to the non shift equivelents\n *\n * this is so you can use keyup events with these keys\n *\n * note that this will only work reliably on US keyboards\n *\n * @type {Object}\n */\nmodule.exports = {\n  '~': '`',\n  '!': '1',\n  '@': '2',\n  '#': '3',\n  '$': '4',\n  '%': '5',\n  '^': '6',\n  '&': '7',\n  '*': '8',\n  '(': '9',\n  ')': '0',\n  '_': '-',\n  '+': '=',\n  ':': ';',\n  '\"': \"'\",\n  '<': ',',\n  '>': '.',\n  '?': '/',\n  '|': '\\\\'\n}\n","/* eslint-env node, browser */\n'use strict'\n/**\n * this is a list of special strings you can use to map\n * to modifier keys when you specify your keyboard shortcuts\n *\n * @type {Object}\n */\nmodule.exports = {\n  'option': 'alt',\n  'command': 'meta',\n  'return': 'enter',\n  'escape': 'esc',\n  'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n}\n","/* eslint-env node, browser */\n'use strict'\n/**\n * mapping for special characters so they can support\n *\n * this dictionary is only used incase you want to bind a\n * keyup or keydown event to one of these keys\n *\n * @type {Object}\n */\nmodule.exports = {\n  106: '*',\n  107: '+',\n  109: '-',\n  110: '.',\n  111: '/',\n  186: ';',\n  187: '=',\n  188: ',',\n  189: '-',\n  190: '.',\n  191: '/',\n  192: '`',\n  219: '[',\n  220: '\\\\',\n  221: ']',\n  222: \"'\"\n}\n","/* eslint-env node, browser */\n'use strict'\n/**\n * mapping of special keycodes to their corresponding keys\n *\n * everything in this dictionary cannot use keypress events\n * so it has to be here to map to the correct keycodes for\n * keyup/keydown events\n *\n * @type {Object}\n */\nmodule.exports = {\n  8: 'backspace',\n  9: 'tab',\n  13: 'enter',\n  16: 'shift',\n  17: 'ctrl',\n  18: 'alt',\n  20: 'capslock',\n  27: 'esc',\n  32: 'space',\n  33: 'pageup',\n  34: 'pagedown',\n  35: 'end',\n  36: 'home',\n  37: 'left',\n  38: 'up',\n  39: 'right',\n  40: 'down',\n  45: 'ins',\n  46: 'del',\n  91: 'meta',\n  93: 'meta',\n  187: 'plus',\n  189: 'minus',\n  224: 'meta'\n}\n\n/**\n * loop through the f keys, f1 to f19 and add them to the map\n * programatically\n */\nfor (var i = 1; i < 20; ++i) {\n  module.exports[111 + i] = 'f' + i\n}\n\n/**\n * loop through to map numbers on the numeric keypad\n */\nfor (i = 0; i <= 9; ++i) {\n  module.exports[i + 96] = i\n}\n","/* eslint-env node, browser */\n'use strict'\n\n/**\n * stops propogation for this event\n *\n * @param {Event} e\n * @returns void\n */\nmodule.exports = function (e) {\n  if (e.stopPropagation) {\n    e.stopPropagation()\n    return\n  }\n\n  e.cancelBubble = true\n}\n","var draw = require('./draw');\r\nvar kb = require('./keyboard');\r\nvar pattern = require('./pattern');\r\n\r\nvar menuCanvas = document.getElementById('menuCanvas');\r\nvar m = menuCanvas.getContext('2d');\r\nmenuCanvas.width = 512;\r\nmenuCanvas.height = 32;\r\nvar m = menuCanvas.getContext('2d');\r\n\r\nvar gameCanvas = document.getElementById('gameCanvas');\r\ngameCanvas.width = 512;\r\ngameCanvas.height = 512;\r\nvar g = gameCanvas.getContext('2d');\r\n\r\nfunction vec2(x,y) {\r\n\treturn { x: x, y: y };\r\n}\r\n\r\nfunction randColor() {\r\n\treturn '#' + Math.floor(Math.random()*16777215).toString(16);\r\n}\r\n\r\nfunction randInt(min, max) {\r\n\treturn Math.round(Math.random() * max) - min;\r\n}\r\n\r\nvar player = {\r\n\ttype: 'player',\r\n\tpos: vec2(gameCanvas.width/2, gameCanvas.height/2),\r\n\tradius: 5,\r\n\tspeed: 3,\r\n\tdeinc: 0.1,\r\n\tcolor: '#333'\r\n};\r\n\r\nvar bullets = { array: [] };\r\n\r\nfunction addBullet(bulletObject) {\r\n\tbullets.array.push(bulletObject);\r\n}\r\n\r\nfunction randomBoundBullet() {\r\n\tif(Math.random() >= 0.5) {\r\n\t\treturn vec2(randInt(0,gameCanvas.width),0);\r\n\t} else {\r\n\t\treturn vec2(0,randInt(0,gameCanvas.height));\r\n\t}\r\n}\r\n\r\nvar func = {\r\n\tapplyPlayerSpeed: function(obj) {\r\n\t\tif(player.speed > 0) {\r\n\t\t\tif(kb.up)    obj.pos.y -= player.speed;\r\n\t\t\tif(kb.down)  obj.pos.y += player.speed;\r\n\t\t\tif(kb.right) obj.pos.x += player.speed;\r\n\t\t\tif(kb.left)  obj.pos.x -= player.speed;\r\n\t\t}\r\n\t},\r\n\tpytha: function(pos1, pos2) {\r\n\t\treturn Math.sqrt(\r\n\t\t\t((pos1.x - pos2.x) * (pos1.x - pos2.x)) +\r\n\t\t\t((pos1.y - pos2.y) * (pos1.y - pos2.y))\r\n\t\t);\r\n\t},\r\n\tdistanceCheck: function(obj1, obj2) {\r\n\t\tpytha = func.pytha(obj1.pos, obj2.pos);\r\n\t\treturn pytha < (obj1.radius + obj2.radius);\r\n\t},\r\n\r\n\tunclog: function(obj1, obj2) {\r\n\t\tvar angle = Math.acos((obj1.pos.x - obj2.pos.x)/func.pytha(obj1.pos, obj2.pos));\r\n\t\tobj2.pos.x = obj1.pos.x - (Math.cos(angle) * (obj1.radius + obj2.radius));\r\n\r\n\t\tif(obj2.pos.y < obj1.pos.y) {\r\n\t\t\tobj2.pos.y = obj1.pos.y - (Math.sin(angle) * (obj1.radius + obj2.radius));\r\n\t\t} else {\r\n\t\t\tobj2.pos.y = obj1.pos.y + (Math.sin(angle) * (obj1.radius + obj2.radius));\r\n\t\t}\r\n\t},\r\n\r\n\tsquareCheck: function(obj1, obj2) {\r\n\t\treturn !(\r\n\t\t\t(obj1.pos.x + obj1.radius) < (obj2.pos.x - obj2.radius) ||\r\n\t\t\t(obj1.pos.y + obj1.radius) < (obj2.pos.y - obj2.radius) ||\r\n\t\t\t(obj1.pos.x - obj1.radius) > (obj2.pos.x + obj2.radius) ||\r\n\t\t\t(obj1.pos.y - obj1.radius) > (obj2.pos.y + obj2.radius)\r\n\t\t);\r\n\t}\r\n};\r\n\r\nvar update = {\r\n\tcollision: function(bullet) {\r\n\t\tif(bullet.isConnected) {\r\n\t\t\t// Connected Collision\r\n\t\t\tfor(var b=0, len = bullets.array.length; b < len; b++) {\r\n\t\t\t\tvar otherBullet = bullets.array[b];\r\n\t\t\t\tif(!otherBullet.isConnected && func.squareCheck(bullet, otherBullet) && func.distanceCheck(bullet, otherBullet)) {\r\n\r\n\t\t\t\t\tfunc.unclog(bullet, otherBullet);\r\n\t\t\t\t\totherBullet.isConnected = true;\r\n\t\t\t\t\tplayer.speed -= otherBullet.radius / 120;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Player Collision\r\n\t\t\tif(func.squareCheck(player, bullet) && func.distanceCheck(player, bullet)) {\r\n\t\t\t\tfunc.unclog(player, bullet);\r\n\r\n\t\t\t\tbullet.isConnected = true;\r\n\t\t\t\tplayer.speed -= bullet.radius / 120;\r\n\t\t\t} else {\r\n\t\t\t\tbullet.pattern(bullet, frame);\r\n\t\t\t\tupdate.swapArround(bullet);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tswapArround: function(obj) {\r\n\t\tif(obj.pos.y < gameCanvas.height * -0.1) obj.pos.y += gameCanvas.height * 1.2;\r\n\t\tif(obj.pos.y > gameCanvas.height * 1.1)  obj.pos.y -= gameCanvas.height * 1.2;\r\n\r\n\t\tif(obj.pos.x > gameCanvas.width * 1.1)   obj.pos.x -= gameCanvas.height * 1.2;\r\n\t\tif(obj.pos.x < gameCanvas.width * -0.1)  obj.pos.x += gameCanvas.height * 1.2;\r\n\t}\r\n};\r\n\r\nvar frame = -1;\r\nvar loop = {\r\n\tmenu: function() {\r\n\t\tframe++;\r\n\r\n\t\trequestAnimationFrame(loop.cur);\r\n\t},\r\n\tgame: function() {\r\n\t\tframe++;\r\n\r\n\t\tdraw.clear(g, gameCanvas);\r\n\r\n\t\tfunc.applyPlayerSpeed(player);\r\n\t\tupdate.swapArround(player);\r\n\t\tdraw.circle(g,player.pos, player.radius, player.color);\r\n\r\n\t\tfor(var i=0, len = bullets.array.length; i < len; i++) {\r\n\t\t\tvar bullet = bullets.array[i];\r\n\t\t\tbullet.xspeed += 0.0005;\r\n\t\t\tbullet.yspeed += 0.0005;\r\n\r\n\t\t\tif(bullet.isConnected) {\r\n\t\t\t\tfunc.applyPlayerSpeed(bullet);\r\n\t\t\t}\r\n\r\n\t\t\tupdate.collision(bullet, i);\r\n\t\t\tdraw.circle(g,bullet.pos,bullet.radius,bullet.color);\r\n\t\t}\r\n\r\n\t\tif(frame % 60 === 0) {\r\n\t\t\taddBullet({\r\n\t\t\t\tpos: \t\t\trandomBoundBullet(),\r\n\t\t\t\tradius: \t6 + randInt(0,8),\r\n\t\t\t\tcolor: \t\trandColor(),\r\n\t\t\t\tspeedpos: vec2(1 + (2 * Math.random()), 1 + (2 * Math.random())),\r\n\t\t\t\tpattern: pattern.wavyDown\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tdraw.clear(m, menuCanvas);\r\n\r\n\t\trequestAnimationFrame(loop.cur);\r\n\t}\r\n};\r\nloop.cur = loop.game;\r\nloop.cur();\r\n","module.exports = {\r\n\tcircle: function(ctx,pos,radius,color) {\r\n\t\tctx.fillStyle = color;\r\n\t\tctx.beginPath();\r\n\t\tctx.arc(pos.x, pos.y, radius, 0, 2*Math.PI);\r\n\t\tctx.fill();\r\n\t},\r\n\tline: function(ctx,pos1,pos2,width,color) {\r\n\t\tctx.beginPath();\r\n\t\tctx.moveTo(pos1.x, pos1.y);\r\n\t\tctx.lineTo(pos2.x, pos2.y);\r\n\t\tctx.lineWidth = width;\r\n\t\tctx.strokeStyle = color;\r\n\t\tctx.stroke();\r\n\t},\r\n\tclear: function(ctx, canvas) {\r\n\t\tctx.fillStyle = 'white';\r\n\t\tctx.fillRect(0,0,canvas.width, canvas.height);\r\n\t},\r\n\r\n\ttext: function(ctx,text,size,color,pos) {\r\n\t\tctx.fillStyle = color;\r\n\t\tctx.font = size.toString() + 'px Helvetica';\r\n\t\tctx.fillText(text, pos.x, pos.y);\r\n\t},\r\n\tmenu: function() {\r\n\t\t// TODO\r\n\t}\r\n};\r\n","var Combokeys = require('combokeys');\nvar canvasInput = new Combokeys(document.documentElement);\n\nvar kb = {\n\tup: false, down: false, left: false, right: false\n};\n\ncanvasInput.bind('up', function() { kb.up = true; }, 'keydown');\ncanvasInput.bind('up', function() { kb.up = false; }, 'keyup');\ncanvasInput.bind('down', function() { kb.down = true; }, 'keydown');\ncanvasInput.bind('down', function() { kb.down = false; }, 'keyup');\ncanvasInput.bind('left', function() { kb.left = true; }, 'keydown');\ncanvasInput.bind('left', function() { kb.left = false; }, 'keyup');\ncanvasInput.bind('right', function() { kb.right = true; }, 'keydown');\ncanvasInput.bind('right', function() { kb.right = false; }, 'keyup');\n\nmodule.exports = kb;\n","module.exports = {\r\n\tdown: function(bullet) {\r\n\t\tbullet.pos.y += bullet.speedpos.y;\r\n\t},\r\n\tsideWays: function(bullet) {\r\n\t\tbullet.pos.y += bullet.speedpos.y;\r\n\t\tbullet.pos.x += bullet.speedpos.x;\r\n\t},\r\n\twavyDown: function(bullet, frame) {\r\n\t\tbullet.pos.y += bullet.speedpos.y + Math.sin((frame)/30);\r\n\t\tbullet.pos.x += Math.sin(frame/(bullet.speedpos.x * 40)) * 2;\r\n\t},\r\n\tawayFromCenter: function(bullet, key) {\r\n    // TODO\r\n\t}\r\n};\r\n"],"sourceRoot":"/source/"}